(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/common/http'), require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('jsrsasign-reduced'), require('@angular/router')) :
    typeof define === 'function' && define.amd ? define('angular-auth-oidc-client', ['exports', '@angular/common', '@angular/common/http', '@angular/core', 'rxjs', 'rxjs/operators', 'jsrsasign-reduced', '@angular/router'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['angular-auth-oidc-client'] = {}, global.ng.common, global.ng.common.http, global.ng.core, global.rxjs, global.rxjs.operators, global['jsrsasign-reduced'], global.ng.router));
}(this, (function (exports, common, i1, i0, rxjs, operators, jsrsasignReduced, i2) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i2__namespace = /*#__PURE__*/_interopNamespace(i2);

    var HttpBaseService = /** @class */ (function () {
        function HttpBaseService(http) {
            this.http = http;
        }
        HttpBaseService.prototype.get = function (url, params) {
            return this.http.get(url, params);
        };
        HttpBaseService.prototype.post = function (url, body, params) {
            return this.http.post(url, body, params);
        };
        return HttpBaseService;
    }());
    HttpBaseService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: HttpBaseService, deps: [{ token: i1__namespace.HttpClient }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    HttpBaseService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: HttpBaseService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: HttpBaseService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace.HttpClient }]; } });

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || from);
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var ConfigurationProvider = /** @class */ (function () {
        function ConfigurationProvider() {
            this.configsInternal = {};
        }
        ConfigurationProvider.prototype.hasAsLeastOneConfig = function () {
            return Object.keys(this.configsInternal).length > 0;
        };
        ConfigurationProvider.prototype.hasManyConfigs = function () {
            return Object.keys(this.configsInternal).length > 1;
        };
        ConfigurationProvider.prototype.setConfig = function (readyConfig) {
            var configId = readyConfig.configId;
            this.configsInternal[configId] = readyConfig;
        };
        ConfigurationProvider.prototype.getOpenIDConfiguration = function (configId) {
            if (!!configId) {
                return this.configsInternal[configId] || null;
            }
            var _a = __read(Object.entries(this.configsInternal)[0] || [[null, null]], 2), value = _a[1];
            return value || null;
        };
        ConfigurationProvider.prototype.getAllConfigurations = function () {
            return Object.values(this.configsInternal);
        };
        return ConfigurationProvider;
    }());
    ConfigurationProvider.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ConfigurationProvider, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ConfigurationProvider.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ConfigurationProvider });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ConfigurationProvider, decorators: [{
                type: i0.Injectable
            }] });

    var NGSW_CUSTOM_PARAM = 'ngsw-bypass';
    var DataService = /** @class */ (function () {
        function DataService(httpClient, configurationProvider) {
            this.httpClient = httpClient;
            this.configurationProvider = configurationProvider;
        }
        DataService.prototype.get = function (url, configId, token) {
            var headers = this.prepareHeaders(token);
            var params = this.prepareParams(configId);
            return this.httpClient.get(url, {
                headers: headers,
                params: params,
            });
        };
        DataService.prototype.post = function (url, body, configId, headersParams) {
            var headers = headersParams || this.prepareHeaders();
            var params = this.prepareParams(configId);
            return this.httpClient.post(url, body, { headers: headers, params: params });
        };
        DataService.prototype.prepareHeaders = function (token) {
            var headers = new i1.HttpHeaders();
            headers = headers.set('Accept', 'application/json');
            if (!!token) {
                headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));
            }
            return headers;
        };
        DataService.prototype.prepareParams = function (configId) {
            var params = new i1.HttpParams();
            var ngswBypass = this.configurationProvider.getOpenIDConfiguration(configId).ngswBypass;
            if (ngswBypass) {
                params = params.set(NGSW_CUSTOM_PARAM, '');
            }
            return params;
        };
        return DataService;
    }());
    DataService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: DataService, deps: [{ token: HttpBaseService }, { token: ConfigurationProvider }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DataService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: DataService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: DataService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: HttpBaseService }, { type: ConfigurationProvider }]; } });

    // eslint-disable-next-line no-shadow
    exports.EventTypes = void 0;
    (function (EventTypes) {
        /**
         *  This only works in the AppModule Constructor
         */
        EventTypes[EventTypes["ConfigLoaded"] = 0] = "ConfigLoaded";
        EventTypes[EventTypes["ConfigLoadingFailed"] = 1] = "ConfigLoadingFailed";
        EventTypes[EventTypes["CheckSessionReceived"] = 2] = "CheckSessionReceived";
        EventTypes[EventTypes["UserDataChanged"] = 3] = "UserDataChanged";
        EventTypes[EventTypes["NewAuthenticationResult"] = 4] = "NewAuthenticationResult";
        EventTypes[EventTypes["TokenExpired"] = 5] = "TokenExpired";
        EventTypes[EventTypes["IdTokenExpired"] = 6] = "IdTokenExpired";
        EventTypes[EventTypes["SilentRenewStarted"] = 7] = "SilentRenewStarted";
    })(exports.EventTypes || (exports.EventTypes = {}));

    // eslint-disable-next-line no-shadow
    exports.LogLevel = void 0;
    (function (LogLevel) {
        LogLevel[LogLevel["None"] = 0] = "None";
        LogLevel[LogLevel["Debug"] = 1] = "Debug";
        LogLevel[LogLevel["Warn"] = 2] = "Warn";
        LogLevel[LogLevel["Error"] = 3] = "Error";
    })(exports.LogLevel || (exports.LogLevel = {}));

    var LoggerService = /** @class */ (function () {
        function LoggerService(configurationProvider) {
            this.configurationProvider = configurationProvider;
        }
        LoggerService.prototype.logError = function (configId, message) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            if (!!configId) {
                this.logErrorWithConfig.apply(this, __spreadArray([configId, message], __read(args)));
            }
            else {
                this.logErrorWithoutConfig.apply(this, __spreadArray([message], __read(args)));
            }
        };
        LoggerService.prototype.logWarning = function (configId, message) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            if (!!configId) {
                this.logWarningWithConfig.apply(this, __spreadArray([configId, message], __read(args)));
            }
            else {
                this.logWarningWithoutConfig.apply(this, __spreadArray([message], __read(args)));
            }
        };
        LoggerService.prototype.logDebug = function (configId, message) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            if (!this.logLevelIsSet(configId)) {
                return;
            }
            if (this.loggingIsTurnedOff(configId)) {
                return;
            }
            if (!this.currentLogLevelIsEqualOrSmallerThan(configId, exports.LogLevel.Debug)) {
                return;
            }
            if (!!args && !!args.length) {
                console.log.apply(console, __spreadArray(["[DEBUG] " + configId + " - " + message], __read(args)));
            }
            else {
                console.log("[DEBUG] " + configId + " - " + message);
            }
        };
        LoggerService.prototype.logWarningWithoutConfig = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!!args && !!args.length) {
                console.warn.apply(console, __spreadArray(["[WARN] - " + message], __read(args)));
            }
            else {
                console.warn("[WARN] - " + message);
            }
        };
        LoggerService.prototype.logWarningWithConfig = function (configId, message) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            if (!this.logLevelIsSet(configId)) {
                return;
            }
            if (this.loggingIsTurnedOff(configId)) {
                return;
            }
            if (!this.currentLogLevelIsEqualOrSmallerThan(configId, exports.LogLevel.Warn)) {
                return;
            }
            if (!!args && !!args.length) {
                console.warn.apply(console, __spreadArray(["[WARN] " + configId + " - " + message], __read(args)));
            }
            else {
                console.warn("[WARN] " + configId + " - " + message);
            }
        };
        LoggerService.prototype.logErrorWithConfig = function (configId, message) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            if (this.loggingIsTurnedOff(configId)) {
                return;
            }
            if (!!args && !!args.length) {
                console.error.apply(console, __spreadArray(["[ERROR] " + configId + " - " + message], __read(args)));
            }
            else {
                console.error("[ERROR] " + configId + " - " + message);
            }
        };
        LoggerService.prototype.logErrorWithoutConfig = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!!args && !!args.length) {
                console.error.apply(console, __spreadArray(["[ERROR] - " + message], __read(args)));
            }
            else {
                console.error("[ERROR] - " + message);
            }
        };
        LoggerService.prototype.currentLogLevelIsEqualOrSmallerThan = function (configId, logLevelToCompare) {
            var logLevel = (this.configurationProvider.getOpenIDConfiguration(configId) || {}).logLevel;
            return logLevel <= logLevelToCompare;
        };
        LoggerService.prototype.logLevelIsSet = function (configId) {
            var logLevel = (this.configurationProvider.getOpenIDConfiguration(configId) || {}).logLevel;
            if (logLevel === null) {
                return false;
            }
            if (logLevel === undefined) {
                return false;
            }
            return true;
        };
        LoggerService.prototype.loggingIsTurnedOff = function (configId) {
            var logLevel = (this.configurationProvider.getOpenIDConfiguration(configId) || {}).logLevel;
            return logLevel === exports.LogLevel.None;
        };
        return LoggerService;
    }());
    LoggerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: LoggerService, deps: [{ token: ConfigurationProvider }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LoggerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: LoggerService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: LoggerService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: ConfigurationProvider }]; } });

    var BrowserStorageService = /** @class */ (function () {
        function BrowserStorageService(configProvider, loggerService) {
            this.configProvider = configProvider;
            this.loggerService = loggerService;
        }
        BrowserStorageService.prototype.read = function (key, configId) {
            if (!this.hasStorage()) {
                this.loggerService.logDebug(configId, "Wanted to read '" + key + "' but Storage was undefined");
                return null;
            }
            var storage = this.getStorage(configId);
            if (!storage) {
                this.loggerService.logDebug(configId, "Wanted to read config for '" + configId + "' but Storage was falsy");
                return null;
            }
            var storedConfig = storage.read(configId);
            if (!storedConfig) {
                return null;
            }
            return JSON.parse(storedConfig);
        };
        BrowserStorageService.prototype.write = function (value, configId) {
            if (!this.hasStorage()) {
                this.loggerService.logDebug(configId, "Wanted to write '" + value + "' but Storage was falsy");
                return false;
            }
            var storage = this.getStorage(configId);
            if (!storage) {
                this.loggerService.logDebug(configId, "Wanted to write '" + value + "' but Storage was falsy");
                return false;
            }
            value = value || null;
            storage.write(configId, JSON.stringify(value));
            return true;
        };
        BrowserStorageService.prototype.remove = function (key, configId) {
            if (!this.hasStorage()) {
                this.loggerService.logDebug(configId, "Wanted to remove '" + key + "' but Storage was falsy");
                return false;
            }
            var storage = this.getStorage(configId);
            if (!storage) {
                this.loggerService.logDebug(configId, "Wanted to write '" + key + "' but Storage was falsy");
                return false;
            }
            storage.remove(key);
            return true;
        };
        // TODO THIS STORAGE WANTS AN ID BUT CLEARS EVERYTHING
        BrowserStorageService.prototype.clear = function (configId) {
            if (!this.hasStorage()) {
                this.loggerService.logDebug(configId, "Wanted to clear storage but Storage was falsy");
                return false;
            }
            var storage = this.getStorage(configId);
            if (!storage) {
                this.loggerService.logDebug(configId, "Wanted to clear storage but Storage was falsy");
                return false;
            }
            storage.clear();
            return true;
        };
        BrowserStorageService.prototype.getStorage = function (configId) {
            var storage = (this.configProvider.getOpenIDConfiguration(configId) || {}).storage;
            return storage;
        };
        BrowserStorageService.prototype.hasStorage = function () {
            return typeof Storage !== 'undefined';
        };
        return BrowserStorageService;
    }());
    BrowserStorageService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: BrowserStorageService, deps: [{ token: ConfigurationProvider }, { token: LoggerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BrowserStorageService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: BrowserStorageService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: BrowserStorageService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: LoggerService }]; } });

    var StoragePersistenceService = /** @class */ (function () {
        function StoragePersistenceService(browserStorageService) {
            this.browserStorageService = browserStorageService;
        }
        StoragePersistenceService.prototype.read = function (key, configId) {
            var storedConfig = this.browserStorageService.read(key, configId) || {};
            return storedConfig[key];
        };
        StoragePersistenceService.prototype.write = function (key, value, configId) {
            var storedConfig = this.browserStorageService.read(key, configId) || {};
            storedConfig[key] = value;
            this.browserStorageService.write(storedConfig, configId);
        };
        StoragePersistenceService.prototype.remove = function (key, configId) {
            var storedConfig = this.browserStorageService.read(key, configId) || {};
            delete storedConfig[key];
            this.browserStorageService.write(storedConfig, configId);
        };
        StoragePersistenceService.prototype.clear = function (configId) {
            this.browserStorageService.clear(configId);
        };
        StoragePersistenceService.prototype.resetStorageFlowData = function (configId) {
            this.remove('session_state', configId);
            this.remove('storageSilentRenewRunning', configId);
            this.remove('codeVerifier', configId);
            this.remove('userData', configId);
            this.remove('storageCustomParamsAuthRequest', configId);
            this.remove('access_token_expires_at', configId);
            this.remove('storageCustomParamsRefresh', configId);
            this.remove('storageCustomParamsEndSession', configId);
        };
        StoragePersistenceService.prototype.resetAuthStateInStorage = function (configId) {
            this.remove('authzData', configId);
            this.remove('authnResult', configId);
        };
        StoragePersistenceService.prototype.getAccessToken = function (configId) {
            return this.read('authzData', configId);
        };
        StoragePersistenceService.prototype.getIdToken = function (configId) {
            var _a;
            return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.id_token;
        };
        StoragePersistenceService.prototype.getRefreshToken = function (configId) {
            var _a;
            return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.refresh_token;
        };
        StoragePersistenceService.prototype.getAuthenticationResult = function (configId) {
            return this.read('authnResult', configId);
        };
        return StoragePersistenceService;
    }());
    StoragePersistenceService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: StoragePersistenceService, deps: [{ token: BrowserStorageService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    StoragePersistenceService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: StoragePersistenceService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: StoragePersistenceService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: BrowserStorageService }]; } });

    var PublicEventsService = /** @class */ (function () {
        function PublicEventsService() {
            this.notify = new rxjs.ReplaySubject(1);
        }
        /**
         * Fires a new event.
         *
         * @param type The event type.
         * @param value The event value.
         */
        PublicEventsService.prototype.fireEvent = function (type, value) {
            this.notify.next({ type: type, value: value });
        };
        /**
         * Wires up the event notification observable.
         */
        PublicEventsService.prototype.registerForEvents = function () {
            return this.notify.asObservable();
        };
        return PublicEventsService;
    }());
    PublicEventsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PublicEventsService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PublicEventsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PublicEventsService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PublicEventsService, decorators: [{
                type: i0.Injectable
            }] });

    var PARTS_OF_TOKEN = 3;
    var TokenHelperService = /** @class */ (function () {
        function TokenHelperService(loggerService) {
            this.loggerService = loggerService;
        }
        TokenHelperService.prototype.getTokenExpirationDate = function (dataIdToken) {
            if (!dataIdToken.hasOwnProperty('exp')) {
                return new Date(new Date().toUTCString());
            }
            var date = new Date(0); // The 0 here is the key, which sets the date to the epoch
            date.setUTCSeconds(dataIdToken.exp);
            return date;
        };
        TokenHelperService.prototype.getHeaderFromToken = function (token, encoded, configId) {
            if (!this.tokenIsValid(token, configId)) {
                return {};
            }
            return this.getPartOfToken(token, 0, encoded);
        };
        TokenHelperService.prototype.getPayloadFromToken = function (token, encoded, configId) {
            if (!this.tokenIsValid(token, configId)) {
                return {};
            }
            return this.getPartOfToken(token, 1, encoded);
        };
        TokenHelperService.prototype.getSignatureFromToken = function (token, encoded, configId) {
            if (!this.tokenIsValid(token, configId)) {
                return {};
            }
            return this.getPartOfToken(token, 2, encoded);
        };
        TokenHelperService.prototype.getPartOfToken = function (token, index, encoded) {
            var partOfToken = this.extractPartOfToken(token, index);
            if (encoded) {
                return partOfToken;
            }
            var result = this.urlBase64Decode(partOfToken);
            return JSON.parse(result);
        };
        TokenHelperService.prototype.urlBase64Decode = function (str) {
            var output = str.replace(/-/g, '+').replace(/_/g, '/');
            switch (output.length % 4) {
                case 0:
                    break;
                case 2:
                    output += '==';
                    break;
                case 3:
                    output += '=';
                    break;
                default:
                    throw Error('Illegal base64url string!');
            }
            var decoded = typeof window !== 'undefined' ? window.atob(output) : Buffer.from(output, 'base64').toString('binary');
            try {
                // Going backwards: from byte stream, to percent-encoding, to original string.
                return decodeURIComponent(decoded
                    .split('')
                    .map(function (c) { return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2); })
                    .join(''));
            }
            catch (err) {
                return decoded;
            }
        };
        TokenHelperService.prototype.tokenIsValid = function (token, configId) {
            if (!token) {
                this.loggerService.logError(configId, "token '" + token + "' is not valid --> token falsy");
                return false;
            }
            if (!token.includes('.')) {
                this.loggerService.logError(configId, "token '" + token + "' is not valid --> no dots included");
                return false;
            }
            var parts = token.split('.');
            if (parts.length !== PARTS_OF_TOKEN) {
                this.loggerService.logError(configId, "token '" + token + "' is not valid --> token has to have exactly " + (PARTS_OF_TOKEN - 1) + " dots");
                return false;
            }
            return true;
        };
        TokenHelperService.prototype.extractPartOfToken = function (token, index) {
            return token.split('.')[index];
        };
        return TokenHelperService;
    }());
    TokenHelperService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: TokenHelperService, deps: [{ token: LoggerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TokenHelperService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: TokenHelperService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: TokenHelperService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: LoggerService }]; } });

    var JsrsAsignReducedService = /** @class */ (function () {
        function JsrsAsignReducedService() {
        }
        JsrsAsignReducedService.prototype.generateCodeChallenge = function (codeVerifier) {
            var hash = jsrsasignReduced.KJUR.crypto.Util.hashString(codeVerifier, 'sha256');
            var testData = jsrsasignReduced.hextob64u(hash);
            return testData;
        };
        JsrsAsignReducedService.prototype.generateAtHash = function (accessToken, sha) {
            var hash = jsrsasignReduced.KJUR.crypto.Util.hashString(accessToken, sha);
            var first128bits = hash.substr(0, hash.length / 2);
            var testData = jsrsasignReduced.hextob64u(first128bits);
            return testData;
        };
        return JsrsAsignReducedService;
    }());
    JsrsAsignReducedService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: JsrsAsignReducedService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    JsrsAsignReducedService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: JsrsAsignReducedService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: JsrsAsignReducedService, decorators: [{
                type: i0.Injectable
            }] });

    // http://openid.net/specs/openid-connect-implicit-1_0.html
    // id_token
    // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)
    // MUST exactly match the value of the iss (issuer) Claim.
    //
    // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified
    // by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,
    // or if it contains additional audiences not trusted by the Client.
    //
    // id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.
    //
    // id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.
    //
    // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the
    // alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.
    //
    // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect
    // Core 1.0
    // [OpenID.Core] specification.
    //
    // id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account
    // for clock skew).
    //
    // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,
    // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.
    //
    // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent
    // in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks
    // is Client specific.
    //
    // id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.
    // The meaning and processing of acr Claim Values is out of scope for this document.
    //
    // id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication
    // if it determines too much time has elapsed since the last End- User authentication.
    // Access Token Validation
    // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]
    // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.
    // access_token C2: Take the left- most half of the hash and base64url- encode it.
    // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present
    // in the ID Token.
    var TokenValidationService = /** @class */ (function () {
        function TokenValidationService(tokenHelperService, loggerService, jsrsAsignReducedService) {
            this.tokenHelperService = tokenHelperService;
            this.loggerService = loggerService;
            this.jsrsAsignReducedService = jsrsAsignReducedService;
            this.keyAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];
        }
        // id_token C7: The current time MUST be before the time represented by the exp Claim
        // (possibly allowing for some small leeway to account for clock skew).
        TokenValidationService.prototype.hasIdTokenExpired = function (token, configId, offsetSeconds) {
            var decoded = this.tokenHelperService.getPayloadFromToken(token, false, configId);
            return !this.validateIdTokenExpNotExpired(decoded, configId, offsetSeconds);
        };
        // id_token C7: The current time MUST be before the time represented by the exp Claim
        // (possibly allowing for some small leeway to account for clock skew).
        TokenValidationService.prototype.validateIdTokenExpNotExpired = function (decodedIdToken, configId, offsetSeconds) {
            var tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);
            offsetSeconds = offsetSeconds || 0;
            if (!tokenExpirationDate) {
                return false;
            }
            var tokenExpirationValue = tokenExpirationDate.valueOf();
            var nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;
            var tokenNotExpired = tokenExpirationValue > nowWithOffset;
            this.loggerService.logDebug(configId, "Has idToken expired: " + !tokenNotExpired + " --> expires in " + this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset) + " , " + new Date(tokenExpirationValue).toLocaleTimeString() + " > " + new Date(nowWithOffset).toLocaleTimeString());
            // Token not expired?
            return tokenNotExpired;
        };
        TokenValidationService.prototype.validateAccessTokenNotExpired = function (accessTokenExpiresAt, configId, offsetSeconds) {
            // value is optional, so if it does not exist, then it has not expired
            if (!accessTokenExpiresAt) {
                return true;
            }
            offsetSeconds = offsetSeconds || 0;
            var accessTokenExpirationValue = accessTokenExpiresAt.valueOf();
            var nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;
            var tokenNotExpired = accessTokenExpirationValue > nowWithOffset;
            this.loggerService.logDebug(configId, "Has accessToken expired: " + !tokenNotExpired + " --> expires in " + this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset) + " , " + new Date(accessTokenExpirationValue).toLocaleTimeString() + " > " + new Date(nowWithOffset).toLocaleTimeString());
            // access token not expired?
            return tokenNotExpired;
        };
        // iss
        // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the
        // https scheme that contains scheme, host,
        // and optionally, port number and path components and no query or fragment components.
        //
        // sub
        // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,
        // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.
        // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.
        //
        // aud
        // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an
        // audience value.
        // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.
        // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.
        //
        // exp
        // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.
        // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.
        // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.
        // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until
        // the date/ time.
        // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.
        //
        // iat
        // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from
        // 1970- 01 - 01T00: 00: 00Z as measured
        // in UTC until the date/ time.
        TokenValidationService.prototype.validateRequiredIdToken = function (dataIdToken, configId) {
            var validated = true;
            if (!dataIdToken.hasOwnProperty('iss')) {
                validated = false;
                this.loggerService.logWarning(configId, 'iss is missing, this is required in the id_token');
            }
            if (!dataIdToken.hasOwnProperty('sub')) {
                validated = false;
                this.loggerService.logWarning(configId, 'sub is missing, this is required in the id_token');
            }
            if (!dataIdToken.hasOwnProperty('aud')) {
                validated = false;
                this.loggerService.logWarning(configId, 'aud is missing, this is required in the id_token');
            }
            if (!dataIdToken.hasOwnProperty('exp')) {
                validated = false;
                this.loggerService.logWarning(configId, 'exp is missing, this is required in the id_token');
            }
            if (!dataIdToken.hasOwnProperty('iat')) {
                validated = false;
                this.loggerService.logWarning(configId, 'iat is missing, this is required in the id_token');
            }
            return validated;
        };
        // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,
        // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.
        TokenValidationService.prototype.validateIdTokenIatMaxOffset = function (dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configId) {
            if (disableIatOffsetValidation) {
                return true;
            }
            if (!dataIdToken.hasOwnProperty('iat')) {
                return false;
            }
            var dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch
            dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);
            maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;
            var nowInUtc = new Date(new Date().toUTCString());
            var diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();
            var maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;
            this.loggerService.logDebug(configId, "validate id token iat max offset " + diff + " < " + maxOffsetAllowedInMilliseconds);
            if (diff > 0) {
                return diff < maxOffsetAllowedInMilliseconds;
            }
            return -diff < maxOffsetAllowedInMilliseconds;
        };
        // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one
        // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.
        // The precise method for detecting replay attacks is Client specific.
        // However the nonce claim SHOULD not be present for the refresh_token grant type
        // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on
        // The current spec is ambiguous and KeyCloak does send it.
        TokenValidationService.prototype.validateIdTokenNonce = function (dataIdToken, localNonce, ignoreNonceAfterRefresh, configId) {
            var isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) && localNonce === TokenValidationService.refreshTokenNoncePlaceholder;
            if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {
                this.loggerService.logDebug(configId, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + localNonce);
                return false;
            }
            return true;
        };
        // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)
        // MUST exactly match the value of the iss (issuer) Claim.
        TokenValidationService.prototype.validateIdTokenIss = function (dataIdToken, authWellKnownEndpointsIssuer, configId) {
            if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {
                this.loggerService.logDebug(configId, 'Validate_id_token_iss failed, dataIdToken.iss: ' +
                    dataIdToken.iss +
                    ' authWellKnownEndpoints issuer:' +
                    authWellKnownEndpointsIssuer);
                return false;
            }
            return true;
        };
        // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified
        // by the iss (issuer) Claim as an audience.
        // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences
        // not trusted by the Client.
        TokenValidationService.prototype.validateIdTokenAud = function (dataIdToken, aud, configId) {
            if (Array.isArray(dataIdToken.aud)) {
                var result = dataIdToken.aud.includes(aud);
                if (!result) {
                    this.loggerService.logDebug(configId, 'Validate_id_token_aud array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);
                    return false;
                }
                return true;
            }
            else if (dataIdToken.aud !== aud) {
                this.loggerService.logDebug(configId, 'Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);
                return false;
            }
            return true;
        };
        TokenValidationService.prototype.validateIdTokenAzpExistsIfMoreThanOneAud = function (dataIdToken) {
            if (!dataIdToken) {
                return false;
            }
            if (Array.isArray(dataIdToken.aud) && dataIdToken.aud.length > 1 && !dataIdToken.azp) {
                return false;
            }
            return true;
        };
        // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.
        TokenValidationService.prototype.validateIdTokenAzpValid = function (dataIdToken, clientId) {
            if (!(dataIdToken === null || dataIdToken === void 0 ? void 0 : dataIdToken.azp)) {
                return true;
            }
            if (dataIdToken.azp === clientId) {
                return true;
            }
            return false;
        };
        TokenValidationService.prototype.validateStateFromHashCallback = function (state, localState, configId) {
            if (state !== localState) {
                this.loggerService.logDebug(configId, 'ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + localState);
                return false;
            }
            return true;
        };
        // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg
        // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.
        // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the
        // OpenID Connect Core 1.0 [OpenID.Core] specification.
        TokenValidationService.prototype.validateSignatureIdToken = function (idToken, jwtkeys, configId) {
            var e_1, _a, e_2, _b;
            if (!jwtkeys || !jwtkeys.keys) {
                return false;
            }
            var headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configId);
            if (Object.keys(headerData).length === 0 && headerData.constructor === Object) {
                this.loggerService.logWarning(configId, 'id token has no header data');
                return false;
            }
            var kid = headerData.kid;
            var alg = headerData.alg;
            if (!this.keyAlgorithms.includes(alg)) {
                this.loggerService.logWarning(configId, 'alg not supported', alg);
                return false;
            }
            var jwtKtyToUse = 'RSA';
            if (alg.charAt(0) === 'E') {
                jwtKtyToUse = 'EC';
            }
            var isValid = false;
            // No kid in the Jose header
            if (!kid) {
                var keyToValidate = void 0;
                // If only one key, use it
                if (jwtkeys.keys.length === 1 && jwtkeys.keys[0].kty === jwtKtyToUse) {
                    keyToValidate = jwtkeys.keys[0];
                }
                else {
                    // More than one key
                    // Make sure there's exactly 1 key candidate
                    // kty "RSA" and "EC" uses "sig"
                    var amountOfMatchingKeys = 0;
                    try {
                        for (var _c = __values(jwtkeys.keys), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var key = _d.value;
                            if (key.kty === jwtKtyToUse && key.use === 'sig') {
                                amountOfMatchingKeys++;
                                keyToValidate = key;
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    if (amountOfMatchingKeys > 1) {
                        this.loggerService.logWarning(configId, 'no ID Token kid claim in JOSE header and multiple supplied in jwks_uri');
                        return false;
                    }
                }
                if (!keyToValidate) {
                    this.loggerService.logWarning(configId, 'no keys found, incorrect Signature, validation failed for id_token');
                    return false;
                }
                isValid = jsrsasignReduced.KJUR.jws.JWS.verify(idToken, jsrsasignReduced.KEYUTIL.getKey(keyToValidate), [alg]);
                if (!isValid) {
                    this.loggerService.logWarning(configId, 'incorrect Signature, validation failed for id_token');
                }
                return isValid;
            }
            else {
                try {
                    // kid in the Jose header of id_token
                    for (var _e = __values(jwtkeys.keys), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var key = _f.value;
                        if (key.kid === kid) {
                            var publicKey = jsrsasignReduced.KEYUTIL.getKey(key);
                            isValid = jsrsasignReduced.KJUR.jws.JWS.verify(idToken, publicKey, [alg]);
                            if (!isValid) {
                                this.loggerService.logWarning(configId, 'incorrect Signature, validation failed for id_token');
                            }
                            return isValid;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            return isValid;
        };
        // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'
        //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {
        ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);
        ////    if (!header_data.hasOwnProperty('kid')) {
        ////        // no kid defined in Jose header
        ////        if (jwtkeys.keys.length != 1) {
        ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');
        ////            return false;
        ////        }
        ////    }
        ////    return true;
        //// }
        // Access Token Validation
        // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]
        // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.
        // access_token C2: Take the left- most half of the hash and base64url- encode it.
        // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash
        // is present in the ID Token.
        TokenValidationService.prototype.validateIdTokenAtHash = function (accessToken, atHash, idTokenAlg, configId) {
            this.loggerService.logDebug(configId, 'at_hash from the server:' + atHash);
            // 'sha256' 'sha384' 'sha512'
            var sha = 'sha256';
            if (idTokenAlg.includes('384')) {
                sha = 'sha384';
            }
            else if (idTokenAlg.includes('512')) {
                sha = 'sha512';
            }
            var testData = this.jsrsAsignReducedService.generateAtHash('' + accessToken, sha);
            this.loggerService.logDebug(configId, 'at_hash client validation not decoded:' + testData);
            if (testData === atHash) {
                return true; // isValid;
            }
            else {
                var testValue = this.jsrsAsignReducedService.generateAtHash('' + decodeURIComponent(accessToken), sha);
                this.loggerService.logDebug(configId, '-gen access--' + testValue);
                if (testValue === atHash) {
                    return true; // isValid
                }
            }
            return false;
        };
        TokenValidationService.prototype.millisToMinutesAndSeconds = function (millis) {
            var minutes = Math.floor(millis / 60000);
            var seconds = ((millis % 60000) / 1000).toFixed(0);
            return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;
        };
        return TokenValidationService;
    }());
    TokenValidationService.refreshTokenNoncePlaceholder = '--RefreshToken--';
    TokenValidationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: TokenValidationService, deps: [{ token: TokenHelperService }, { token: LoggerService }, { token: JsrsAsignReducedService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TokenValidationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: TokenValidationService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: TokenValidationService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: TokenHelperService }, { type: LoggerService }, { type: JsrsAsignReducedService }]; } });

    var DEFAULT_AUTHRESULT = { isAuthenticated: false, allConfigsAuthenticated: [] };
    var AuthStateService = /** @class */ (function () {
        function AuthStateService(storagePersistenceService, loggerService, publicEventsService, configurationProvider, tokenValidationService) {
            this.storagePersistenceService = storagePersistenceService;
            this.loggerService = loggerService;
            this.publicEventsService = publicEventsService;
            this.configurationProvider = configurationProvider;
            this.tokenValidationService = tokenValidationService;
            this.authenticatedInternal$ = new rxjs.BehaviorSubject(DEFAULT_AUTHRESULT);
        }
        Object.defineProperty(AuthStateService.prototype, "authenticated$", {
            get: function () {
                return this.authenticatedInternal$.asObservable().pipe(operators.distinctUntilChanged());
            },
            enumerable: false,
            configurable: true
        });
        AuthStateService.prototype.setAuthenticatedAndFireEvent = function () {
            var result = this.composeAuthenticatedResult();
            this.authenticatedInternal$.next(result);
        };
        AuthStateService.prototype.setUnauthenticatedAndFireEvent = function (configIdToReset) {
            this.storagePersistenceService.resetAuthStateInStorage(configIdToReset);
            var result = this.composeUnAuthenticatedResult();
            this.authenticatedInternal$.next(result);
        };
        AuthStateService.prototype.updateAndPublishAuthState = function (authenticationResult) {
            this.publicEventsService.fireEvent(exports.EventTypes.NewAuthenticationResult, authenticationResult);
        };
        AuthStateService.prototype.setAuthorizationData = function (accessToken, authResult, configId) {
            this.loggerService.logDebug(configId, "storing the accessToken '" + accessToken + "'");
            this.storagePersistenceService.write('authzData', accessToken, configId);
            this.persistAccessTokenExpirationTime(authResult, configId);
            this.setAuthenticatedAndFireEvent();
        };
        AuthStateService.prototype.getAccessToken = function (configId) {
            if (!this.isAuthenticated(configId)) {
                return null;
            }
            var token = this.storagePersistenceService.getAccessToken(configId);
            return this.decodeURIComponentSafely(token);
        };
        AuthStateService.prototype.getIdToken = function (configId) {
            if (!this.isAuthenticated(configId)) {
                return null;
            }
            var token = this.storagePersistenceService.getIdToken(configId);
            return this.decodeURIComponentSafely(token);
        };
        AuthStateService.prototype.getRefreshToken = function (configId) {
            if (!this.isAuthenticated(configId)) {
                return null;
            }
            var token = this.storagePersistenceService.getRefreshToken(configId);
            return this.decodeURIComponentSafely(token);
        };
        AuthStateService.prototype.getAuthenticationResult = function (configId) {
            if (!this.isAuthenticated(configId)) {
                return null;
            }
            return this.storagePersistenceService.getAuthenticationResult(configId);
        };
        AuthStateService.prototype.areAuthStorageTokensValid = function (configId) {
            if (!this.isAuthenticated(configId)) {
                return false;
            }
            if (this.hasIdTokenExpiredAndRenewCheckIsEnabled(configId)) {
                this.loggerService.logDebug(configId, 'persisted idToken is expired');
                return false;
            }
            if (this.hasAccessTokenExpiredIfExpiryExists(configId)) {
                this.loggerService.logDebug(configId, 'persisted accessToken is expired');
                return false;
            }
            this.loggerService.logDebug(configId, 'persisted idToken and accessToken are valid');
            return true;
        };
        AuthStateService.prototype.hasIdTokenExpiredAndRenewCheckIsEnabled = function (configId) {
            var _a = this.configurationProvider.getOpenIDConfiguration(configId), renewTimeBeforeTokenExpiresInSeconds = _a.renewTimeBeforeTokenExpiresInSeconds, enableIdTokenExpiredValidationInRenew = _a.enableIdTokenExpiredValidationInRenew;
            if (!enableIdTokenExpiredValidationInRenew) {
                return false;
            }
            var tokenToCheck = this.storagePersistenceService.getIdToken(configId);
            var idTokenExpired = this.tokenValidationService.hasIdTokenExpired(tokenToCheck, configId, renewTimeBeforeTokenExpiresInSeconds);
            if (idTokenExpired) {
                this.publicEventsService.fireEvent(exports.EventTypes.IdTokenExpired, idTokenExpired);
            }
            return idTokenExpired;
        };
        AuthStateService.prototype.hasAccessTokenExpiredIfExpiryExists = function (configId) {
            var renewTimeBeforeTokenExpiresInSeconds = this.configurationProvider.getOpenIDConfiguration(configId).renewTimeBeforeTokenExpiresInSeconds;
            var accessTokenExpiresIn = this.storagePersistenceService.read('access_token_expires_at', configId);
            var accessTokenHasNotExpired = this.tokenValidationService.validateAccessTokenNotExpired(accessTokenExpiresIn, configId, renewTimeBeforeTokenExpiresInSeconds);
            var hasExpired = !accessTokenHasNotExpired;
            if (hasExpired) {
                this.publicEventsService.fireEvent(exports.EventTypes.TokenExpired, hasExpired);
            }
            return hasExpired;
        };
        AuthStateService.prototype.isAuthenticated = function (configId) {
            return !!this.storagePersistenceService.getAccessToken(configId) && !!this.storagePersistenceService.getIdToken(configId);
        };
        AuthStateService.prototype.decodeURIComponentSafely = function (token) {
            if (token) {
                return decodeURIComponent(token);
            }
            else {
                return '';
            }
        };
        AuthStateService.prototype.persistAccessTokenExpirationTime = function (authResult, configId) {
            if (authResult === null || authResult === void 0 ? void 0 : authResult.expires_in) {
                var accessTokenExpiryTime = new Date(new Date().toUTCString()).valueOf() + authResult.expires_in * 1000;
                this.storagePersistenceService.write('access_token_expires_at', accessTokenExpiryTime, configId);
            }
        };
        AuthStateService.prototype.composeAuthenticatedResult = function () {
            if (!this.configurationProvider.hasManyConfigs()) {
                var configId = this.configurationProvider.getOpenIDConfiguration().configId;
                return { isAuthenticated: true, allConfigsAuthenticated: [{ configId: configId, isAuthenticated: true }] };
            }
            return this.checkAllConfigsIfTheyAreAuthenticated();
        };
        AuthStateService.prototype.composeUnAuthenticatedResult = function () {
            if (!this.configurationProvider.hasManyConfigs()) {
                var configId = this.configurationProvider.getOpenIDConfiguration().configId;
                return { isAuthenticated: false, allConfigsAuthenticated: [{ configId: configId, isAuthenticated: false }] };
            }
            return this.checkAllConfigsIfTheyAreAuthenticated();
        };
        AuthStateService.prototype.checkAllConfigsIfTheyAreAuthenticated = function () {
            var _this = this;
            var configs = this.configurationProvider.getAllConfigurations();
            var allConfigsAuthenticated = configs.map(function (_a) {
                var configId = _a.configId;
                return ({
                    configId: configId,
                    isAuthenticated: _this.isAuthenticated(configId),
                });
            });
            var isAuthenticated = allConfigsAuthenticated.every(function (x) { return !!x.isAuthenticated; });
            return { allConfigsAuthenticated: allConfigsAuthenticated, isAuthenticated: isAuthenticated };
        };
        return AuthStateService;
    }());
    AuthStateService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthStateService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: PublicEventsService }, { token: ConfigurationProvider }, { token: TokenValidationService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthStateService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthStateService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthStateService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: PublicEventsService }, { type: ConfigurationProvider }, { type: TokenValidationService }]; } });

    var STORAGE_KEY = 'redirect';
    var AutoLoginService = /** @class */ (function () {
        function AutoLoginService(storageService, router) {
            this.storageService = storageService;
            this.router = router;
        }
        AutoLoginService.prototype.checkSavedRedirectRouteAndNavigate = function (configId) {
            var savedRouteForRedirect = this.getStoredRedirectRoute(configId);
            if (savedRouteForRedirect) {
                this.deleteStoredRedirectRoute(configId);
                this.router.navigateByUrl(savedRouteForRedirect);
            }
        };
        /**
         * Saves the redirect URL to storage.
         *
         * @param url The redirect URL to save.
         */
        AutoLoginService.prototype.saveRedirectRoute = function (configId, url) {
            this.storageService.write(STORAGE_KEY, url, configId);
        };
        /**
         * Gets the stored redirect URL from storage.
         */
        AutoLoginService.prototype.getStoredRedirectRoute = function (configId) {
            return this.storageService.read(STORAGE_KEY, configId);
        };
        /**
         * Removes the redirect URL from storage.
         */
        AutoLoginService.prototype.deleteStoredRedirectRoute = function (configId) {
            this.storageService.remove(STORAGE_KEY, configId);
        };
        return AutoLoginService;
    }());
    AutoLoginService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AutoLoginService, deps: [{ token: StoragePersistenceService }, { token: i2__namespace.Router }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AutoLoginService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AutoLoginService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AutoLoginService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: i2__namespace.Router }]; } });

    var UriEncoder = /** @class */ (function () {
        function UriEncoder() {
        }
        UriEncoder.prototype.encodeKey = function (key) {
            return encodeURIComponent(key);
        };
        UriEncoder.prototype.encodeValue = function (value) {
            return encodeURIComponent(value);
        };
        UriEncoder.prototype.decodeKey = function (key) {
            return decodeURIComponent(key);
        };
        UriEncoder.prototype.decodeValue = function (value) {
            return decodeURIComponent(value);
        };
        return UriEncoder;
    }());

    var RandomService = /** @class */ (function () {
        function RandomService(doc, loggerService) {
            this.doc = doc;
            this.loggerService = loggerService;
        }
        RandomService.prototype.createRandom = function (requiredLength, configId) {
            if (requiredLength <= 0) {
                return '';
            }
            if (requiredLength > 0 && requiredLength < 7) {
                this.loggerService.logWarning(configId, "RandomService called with " + requiredLength + " but 7 chars is the minimum, returning 10 chars");
                requiredLength = 10;
            }
            var length = requiredLength - 6;
            var arr = new Uint8Array(Math.floor((length || length) / 2));
            if (this.getCrypto()) {
                this.getCrypto().getRandomValues(arr);
            }
            return Array.from(arr, this.toHex).join('') + this.randomString(7);
        };
        RandomService.prototype.toHex = function (dec) {
            return ('0' + dec.toString(16)).substr(-2);
        };
        RandomService.prototype.randomString = function (length) {
            var result = '';
            var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            var values = new Uint32Array(length);
            if (this.getCrypto()) {
                this.getCrypto().getRandomValues(values);
                for (var i = 0; i < length; i++) {
                    result += characters[values[i] % characters.length];
                }
            }
            return result;
        };
        RandomService.prototype.getCrypto = function () {
            // support for IE,  (window.crypto || window.msCrypto)
            return this.doc.defaultView.crypto || this.doc.defaultView.msCrypto;
        };
        return RandomService;
    }());
    RandomService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RandomService, deps: [{ token: common.DOCUMENT }, { token: LoggerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RandomService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RandomService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RandomService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [common.DOCUMENT]
                        }] }, { type: LoggerService }];
        } });

    var FlowsDataService = /** @class */ (function () {
        function FlowsDataService(storagePersistenceService, randomService, configurationProvider, loggerService) {
            this.storagePersistenceService = storagePersistenceService;
            this.randomService = randomService;
            this.configurationProvider = configurationProvider;
            this.loggerService = loggerService;
        }
        FlowsDataService.prototype.createNonce = function (configId) {
            var nonce = this.randomService.createRandom(40, configId);
            this.loggerService.logDebug(configId, 'Nonce created. nonce:' + nonce);
            this.setNonce(nonce, configId);
            return nonce;
        };
        FlowsDataService.prototype.setNonce = function (nonce, configId) {
            this.storagePersistenceService.write('authNonce', nonce, configId);
        };
        FlowsDataService.prototype.getAuthStateControl = function (configId) {
            return this.storagePersistenceService.read('authStateControl', configId);
        };
        FlowsDataService.prototype.setAuthStateControl = function (authStateControl, configId) {
            this.storagePersistenceService.write('authStateControl', authStateControl, configId);
        };
        FlowsDataService.prototype.getExistingOrCreateAuthStateControl = function (configId) {
            var state = this.storagePersistenceService.read('authStateControl', configId);
            if (!state) {
                state = this.randomService.createRandom(40, configId);
                this.storagePersistenceService.write('authStateControl', state, configId);
            }
            return state;
        };
        FlowsDataService.prototype.setSessionState = function (sessionState, configId) {
            this.storagePersistenceService.write('session_state', sessionState, configId);
        };
        FlowsDataService.prototype.resetStorageFlowData = function (configId) {
            this.storagePersistenceService.resetStorageFlowData(configId);
        };
        FlowsDataService.prototype.getCodeVerifier = function (configId) {
            return this.storagePersistenceService.read('codeVerifier', configId);
        };
        FlowsDataService.prototype.createCodeVerifier = function (configId) {
            var codeVerifier = this.randomService.createRandom(67, configId);
            this.storagePersistenceService.write('codeVerifier', codeVerifier, configId);
            return codeVerifier;
        };
        FlowsDataService.prototype.isSilentRenewRunning = function (configId) {
            var storageObject = this.getSilentRenewRunningStorageEntry(configId);
            if (!storageObject) {
                return false;
            }
            var silentRenewTimeoutInSeconds = this.configurationProvider.getOpenIDConfiguration(configId).silentRenewTimeoutInSeconds;
            var timeOutInMilliseconds = silentRenewTimeoutInSeconds * 1000;
            var dateOfLaunchedProcessUtc = Date.parse(storageObject.dateOfLaunchedProcessUtc);
            var currentDateUtc = Date.parse(new Date().toISOString());
            var elapsedTimeInMilliseconds = Math.abs(currentDateUtc - dateOfLaunchedProcessUtc);
            var isProbablyStuck = elapsedTimeInMilliseconds > timeOutInMilliseconds;
            if (isProbablyStuck) {
                this.loggerService.logDebug(configId, 'silent renew process is probably stuck, state will be reset.', configId);
                this.resetSilentRenewRunning(configId);
                return false;
            }
            return storageObject.state === 'running';
        };
        FlowsDataService.prototype.setSilentRenewRunning = function (configId) {
            var storageObject = {
                state: 'running',
                dateOfLaunchedProcessUtc: new Date().toISOString(),
            };
            this.storagePersistenceService.write('storageSilentRenewRunning', JSON.stringify(storageObject), configId);
        };
        FlowsDataService.prototype.resetSilentRenewRunning = function (configId) {
            this.storagePersistenceService.write('storageSilentRenewRunning', '', configId);
        };
        FlowsDataService.prototype.getSilentRenewRunningStorageEntry = function (configId) {
            var storageEntry = this.storagePersistenceService.read('storageSilentRenewRunning', configId);
            if (!storageEntry) {
                return null;
            }
            return JSON.parse(storageEntry);
        };
        return FlowsDataService;
    }());
    FlowsDataService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: FlowsDataService, deps: [{ token: StoragePersistenceService }, { token: RandomService }, { token: ConfigurationProvider }, { token: LoggerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FlowsDataService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: FlowsDataService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: FlowsDataService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: RandomService }, { type: ConfigurationProvider }, { type: LoggerService }]; } });

    var FlowHelper = /** @class */ (function () {
        function FlowHelper(configurationProvider) {
            this.configurationProvider = configurationProvider;
        }
        FlowHelper.prototype.isCurrentFlowCodeFlow = function (configId) {
            return this.currentFlowIs('code', configId);
        };
        FlowHelper.prototype.isCurrentFlowAnyImplicitFlow = function (configId) {
            return this.isCurrentFlowImplicitFlowWithAccessToken(configId) || this.isCurrentFlowImplicitFlowWithoutAccessToken(configId);
        };
        FlowHelper.prototype.isCurrentFlowCodeFlowWithRefreshTokens = function (configId) {
            var useRefreshToken = this.configurationProvider.getOpenIDConfiguration(configId).useRefreshToken;
            if (this.isCurrentFlowCodeFlow(configId) && useRefreshToken) {
                return true;
            }
            return false;
        };
        FlowHelper.prototype.isCurrentFlowImplicitFlowWithAccessToken = function (configId) {
            return this.currentFlowIs('id_token token', configId);
        };
        FlowHelper.prototype.currentFlowIs = function (flowTypes, configId) {
            var responseType = this.configurationProvider.getOpenIDConfiguration(configId).responseType;
            if (Array.isArray(flowTypes)) {
                return flowTypes.some(function (x) { return responseType === x; });
            }
            return responseType === flowTypes;
        };
        FlowHelper.prototype.isCurrentFlowImplicitFlowWithoutAccessToken = function (configId) {
            return this.currentFlowIs('id_token', configId);
        };
        return FlowHelper;
    }());
    FlowHelper.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: FlowHelper, deps: [{ token: ConfigurationProvider }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FlowHelper.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: FlowHelper });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: FlowHelper, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: ConfigurationProvider }]; } });

    var CALLBACK_PARAMS_TO_CHECK = ['code', 'state', 'token', 'id_token'];
    var AUTH0_ENDPOINT = 'auth0.com';
    var UrlService = /** @class */ (function () {
        function UrlService(configurationProvider, loggerService, flowsDataService, flowHelper, storagePersistenceService, jsrsAsignReducedService) {
            this.configurationProvider = configurationProvider;
            this.loggerService = loggerService;
            this.flowsDataService = flowsDataService;
            this.flowHelper = flowHelper;
            this.storagePersistenceService = storagePersistenceService;
            this.jsrsAsignReducedService = jsrsAsignReducedService;
        }
        UrlService.prototype.getUrlParameter = function (urlToCheck, name) {
            if (!urlToCheck) {
                return '';
            }
            if (!name) {
                return '';
            }
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            var results = regex.exec(urlToCheck);
            return results === null ? '' : decodeURIComponent(results[1]);
        };
        UrlService.prototype.isCallbackFromSts = function (currentUrl) {
            var _this = this;
            return CALLBACK_PARAMS_TO_CHECK.some(function (x) { return !!_this.getUrlParameter(currentUrl, x); });
        };
        UrlService.prototype.getRefreshSessionSilentRenewUrl = function (configId, customParams) {
            if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {
                return this.createUrlCodeFlowWithSilentRenew(configId, customParams);
            }
            return this.createUrlImplicitFlowWithSilentRenew(configId, customParams) || '';
        };
        UrlService.prototype.getAuthorizeParUrl = function (requestUri, configId) {
            var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            if (!authWellKnownEndPoints) {
                this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');
                return null;
            }
            var authorizationEndpoint = authWellKnownEndPoints.authorizationEndpoint;
            if (!authorizationEndpoint) {
                this.loggerService.logError(configId, "Can not create an authorize URL when authorizationEndpoint is '" + authorizationEndpoint + "'");
                return null;
            }
            var clientId = this.configurationProvider.getOpenIDConfiguration(configId).clientId;
            if (!clientId) {
                this.loggerService.logError(configId, "getAuthorizeParUrl could not add clientId because it was: ", clientId);
                return null;
            }
            var urlParts = authorizationEndpoint.split('?');
            var authorizationUrl = urlParts[0];
            var existingParams = urlParts[1];
            var params = this.createHttpParams(existingParams);
            params = params.set('request_uri', requestUri);
            params = params.append('client_id', clientId);
            return authorizationUrl + "?" + params;
        };
        UrlService.prototype.getAuthorizeUrl = function (configId, customParams) {
            if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {
                return this.createUrlCodeFlowAuthorize(configId, customParams);
            }
            return this.createUrlImplicitFlowAuthorize(configId, customParams) || '';
        };
        UrlService.prototype.createEndSessionUrl = function (idTokenHint, configId, customParamsEndSession) {
            // Auth0 needs a special logout url
            // See https://auth0.com/docs/api/authentication#logout
            if (this.isAuth0Endpoint(configId)) {
                return this.composeAuth0Endpoint(configId);
            }
            var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            var endSessionEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.endSessionEndpoint;
            if (!endSessionEndpoint) {
                return null;
            }
            var urlParts = endSessionEndpoint.split('?');
            var authorizationEndSessionUrl = urlParts[0];
            var existingParams = urlParts[1];
            var params = this.createHttpParams(existingParams);
            params = params.set('id_token_hint', idTokenHint);
            var postLogoutRedirectUri = this.getPostLogoutRedirectUrl(configId);
            if (postLogoutRedirectUri) {
                params = params.append('post_logout_redirect_uri', postLogoutRedirectUri);
            }
            if (customParamsEndSession) {
                params = this.appendCustomParams(Object.assign({}, customParamsEndSession), params);
            }
            return authorizationEndSessionUrl + "?" + params;
        };
        UrlService.prototype.createRevocationEndpointBodyAccessToken = function (token, configId) {
            var clientId = this.getClientId(configId);
            if (!clientId) {
                return null;
            }
            var params = this.createHttpParams();
            params = params.set('client_id', clientId);
            params = params.set('token', token);
            params = params.set('token_type_hint', 'access_token');
            return params.toString();
        };
        UrlService.prototype.createRevocationEndpointBodyRefreshToken = function (token, configId) {
            var clientId = this.getClientId(configId);
            if (!clientId) {
                return null;
            }
            var params = this.createHttpParams();
            params = params.set('client_id', clientId);
            params = params.set('token', token);
            params = params.set('token_type_hint', 'refresh_token');
            return params.toString();
        };
        UrlService.prototype.getRevocationEndpointUrl = function (configId) {
            var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            var revocationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.revocationEndpoint;
            if (!revocationEndpoint) {
                return null;
            }
            var urlParts = revocationEndpoint.split('?');
            var revocationEndpointUrl = urlParts[0];
            return revocationEndpointUrl;
        };
        UrlService.prototype.createBodyForCodeFlowCodeRequest = function (code, configId, customTokenParams) {
            var codeVerifier = this.flowsDataService.getCodeVerifier(configId);
            if (!codeVerifier) {
                this.loggerService.logError(configId, "CodeVerifier is not set ", codeVerifier);
                return null;
            }
            var clientId = this.getClientId(configId);
            if (!clientId) {
                return null;
            }
            var params = this.createHttpParams();
            params = params.set('grant_type', 'authorization_code');
            params = params.set('client_id', clientId);
            params = params.set('code_verifier', codeVerifier);
            params = params.set('code', code);
            if (customTokenParams) {
                params = this.appendCustomParams(Object.assign({}, customTokenParams), params);
            }
            var silentRenewUrl = this.getSilentRenewUrl(configId);
            if (this.flowsDataService.isSilentRenewRunning(configId) && silentRenewUrl) {
                params = params.set('redirect_uri', silentRenewUrl);
                return params.toString();
            }
            var redirectUrl = this.getRedirectUrl(configId);
            if (!redirectUrl) {
                return null;
            }
            params = params.set('redirect_uri', redirectUrl);
            return params.toString();
        };
        UrlService.prototype.createBodyForCodeFlowRefreshTokensRequest = function (refreshToken, configId, customParamsRefresh) {
            var clientId = this.getClientId(configId);
            if (!clientId) {
                return null;
            }
            var params = this.createHttpParams();
            params = params.set('grant_type', 'refresh_token');
            params = params.set('client_id', clientId);
            params = params.set('refresh_token', refreshToken);
            if (customParamsRefresh) {
                params = this.appendCustomParams(Object.assign({}, customParamsRefresh), params);
            }
            return params.toString();
        };
        UrlService.prototype.createBodyForParCodeFlowRequest = function (configId, customParamsRequest) {
            var redirectUrl = this.getRedirectUrl(configId);
            if (!redirectUrl) {
                return null;
            }
            var state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);
            var nonce = this.flowsDataService.createNonce(configId);
            this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);
            // code_challenge with "S256"
            var codeVerifier = this.flowsDataService.createCodeVerifier(configId);
            var codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);
            var _a = this.configurationProvider.getOpenIDConfiguration(configId), clientId = _a.clientId, responseType = _a.responseType, scope = _a.scope, hdParam = _a.hdParam, customParamsAuthRequest = _a.customParamsAuthRequest;
            var params = this.createHttpParams('');
            params = params.set('client_id', clientId);
            params = params.append('redirect_uri', redirectUrl);
            params = params.append('response_type', responseType);
            params = params.append('scope', scope);
            params = params.append('nonce', nonce);
            params = params.append('state', state);
            params = params.append('code_challenge', codeChallenge);
            params = params.append('code_challenge_method', 'S256');
            if (hdParam) {
                params = params.append('hd', hdParam);
            }
            if (customParamsAuthRequest) {
                params = this.appendCustomParams(Object.assign({}, customParamsAuthRequest), params);
            }
            if (customParamsRequest) {
                params = this.appendCustomParams(Object.assign({}, customParamsRequest), params);
            }
            return params.toString();
        };
        UrlService.prototype.createAuthorizeUrl = function (codeChallenge, redirectUrl, nonce, state, configId, prompt, customRequestParams) {
            var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            var authorizationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.authorizationEndpoint;
            if (!authorizationEndpoint) {
                this.loggerService.logError(configId, "Can not create an authorize URL when authorizationEndpoint is '" + authorizationEndpoint + "'");
                return null;
            }
            var _a = this.configurationProvider.getOpenIDConfiguration(configId), clientId = _a.clientId, responseType = _a.responseType, scope = _a.scope, hdParam = _a.hdParam, customParamsAuthRequest = _a.customParamsAuthRequest;
            if (!clientId) {
                this.loggerService.logError(configId, "createAuthorizeUrl could not add clientId because it was: ", clientId);
                return null;
            }
            if (!responseType) {
                this.loggerService.logError(configId, "createAuthorizeUrl could not add responseType because it was: ", responseType);
                return null;
            }
            if (!scope) {
                this.loggerService.logError(configId, "createAuthorizeUrl could not add scope because it was: ", scope);
                return null;
            }
            var urlParts = authorizationEndpoint.split('?');
            var authorizationUrl = urlParts[0];
            var existingParams = urlParts[1];
            var params = this.createHttpParams(existingParams);
            params = params.set('client_id', clientId);
            params = params.append('redirect_uri', redirectUrl);
            params = params.append('response_type', responseType);
            params = params.append('scope', scope);
            params = params.append('nonce', nonce);
            params = params.append('state', state);
            if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {
                params = params.append('code_challenge', codeChallenge);
                params = params.append('code_challenge_method', 'S256');
            }
            var mergedParams = Object.assign(Object.assign({}, customParamsAuthRequest), customRequestParams);
            if (Object.keys(mergedParams).length > 0) {
                params = this.appendCustomParams(Object.assign({}, mergedParams), params);
            }
            if (prompt) {
                params = this.overWriteParam(params, 'prompt', prompt);
            }
            if (hdParam) {
                params = params.append('hd', hdParam);
            }
            return authorizationUrl + "?" + params;
        };
        UrlService.prototype.createUrlImplicitFlowWithSilentRenew = function (configId, customParams) {
            var state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);
            var nonce = this.flowsDataService.createNonce(configId);
            var silentRenewUrl = this.getSilentRenewUrl(configId);
            if (!silentRenewUrl) {
                return null;
            }
            this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ', state);
            var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            if (authWellKnownEndPoints) {
                return this.createAuthorizeUrl('', silentRenewUrl, nonce, state, configId, 'none', customParams);
            }
            this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');
            return null;
        };
        UrlService.prototype.createUrlCodeFlowWithSilentRenew = function (configId, customParams) {
            var state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);
            var nonce = this.flowsDataService.createNonce(configId);
            this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ' + state);
            // code_challenge with "S256"
            var codeVerifier = this.flowsDataService.createCodeVerifier(configId);
            var codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);
            var silentRenewUrl = this.getSilentRenewUrl(configId);
            if (!silentRenewUrl) {
                return null;
            }
            var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            if (authWellKnownEndPoints) {
                return this.createAuthorizeUrl(codeChallenge, silentRenewUrl, nonce, state, configId, 'none', customParams);
            }
            this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');
            return null;
        };
        UrlService.prototype.createUrlImplicitFlowAuthorize = function (configId, customParams) {
            var state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);
            var nonce = this.flowsDataService.createNonce(configId);
            this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);
            var redirectUrl = this.getRedirectUrl(configId);
            if (!redirectUrl) {
                return null;
            }
            var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            if (authWellKnownEndPoints) {
                return this.createAuthorizeUrl('', redirectUrl, nonce, state, configId, null, customParams);
            }
            this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');
            return null;
        };
        UrlService.prototype.createUrlCodeFlowAuthorize = function (configId, customParams) {
            var state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);
            var nonce = this.flowsDataService.createNonce(configId);
            this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);
            var redirectUrl = this.getRedirectUrl(configId);
            if (!redirectUrl) {
                return null;
            }
            // code_challenge with "S256"
            var codeVerifier = this.flowsDataService.createCodeVerifier(configId);
            var codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);
            var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            if (authWellKnownEndPoints) {
                return this.createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, null, customParams);
            }
            this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');
            return null;
        };
        UrlService.prototype.getRedirectUrl = function (configId) {
            var redirectUrl = this.configurationProvider.getOpenIDConfiguration(configId).redirectUrl;
            if (!redirectUrl) {
                this.loggerService.logError(configId, "could not get redirectUrl, was: ", redirectUrl);
                null;
            }
            return redirectUrl;
        };
        UrlService.prototype.getSilentRenewUrl = function (configId) {
            var silentRenewUrl = this.configurationProvider.getOpenIDConfiguration(configId).silentRenewUrl;
            if (!silentRenewUrl) {
                this.loggerService.logError(configId, "could not get silentRenewUrl, was: ", silentRenewUrl);
                return null;
            }
            return silentRenewUrl;
        };
        UrlService.prototype.getPostLogoutRedirectUrl = function (configId) {
            var postLogoutRedirectUri = this.configurationProvider.getOpenIDConfiguration(configId).postLogoutRedirectUri;
            if (!postLogoutRedirectUri) {
                this.loggerService.logError(configId, "could not get postLogoutRedirectUri, was: ", postLogoutRedirectUri);
                return null;
            }
            return postLogoutRedirectUri;
        };
        UrlService.prototype.getClientId = function (configId) {
            var clientId = this.configurationProvider.getOpenIDConfiguration(configId).clientId;
            if (!clientId) {
                this.loggerService.logError(configId, "could not get clientId, was: ", clientId);
                return null;
            }
            return clientId;
        };
        UrlService.prototype.appendCustomParams = function (customParams, params) {
            var e_1, _a;
            try {
                for (var _b = __values(Object.entries(Object.assign({}, customParams))), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                    params = params.append(key, value.toString());
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return params;
        };
        UrlService.prototype.overWriteParam = function (params, key, value) {
            return params.set(key, value);
        };
        UrlService.prototype.createHttpParams = function (existingParams) {
            existingParams = existingParams !== null && existingParams !== void 0 ? existingParams : '';
            var params = new i1.HttpParams({
                fromString: existingParams,
                encoder: new UriEncoder(),
            });
            return params;
        };
        UrlService.prototype.isAuth0Endpoint = function (configId) {
            var authority = this.configurationProvider.getOpenIDConfiguration(configId).authority;
            if (!authority) {
                return false;
            }
            return authority.endsWith(AUTH0_ENDPOINT);
        };
        UrlService.prototype.composeAuth0Endpoint = function (configId) {
            // format: https://YOUR_DOMAIN/v2/logout?client_id=YOUR_CLIENT_ID&returnTo=LOGOUT_URL
            var _a = this.configurationProvider.getOpenIDConfiguration(configId), authority = _a.authority, clientId = _a.clientId;
            var postLogoutRedirectUrl = this.getPostLogoutRedirectUrl(configId);
            return authority + "/v2/logout?client_id=" + clientId + "&returnTo=" + postLogoutRedirectUrl;
        };
        return UrlService;
    }());
    UrlService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: UrlService, deps: [{ token: ConfigurationProvider }, { token: LoggerService }, { token: FlowsDataService }, { token: FlowHelper }, { token: StoragePersistenceService }, { token: JsrsAsignReducedService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UrlService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: UrlService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: UrlService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: LoggerService }, { type: FlowsDataService }, { type: FlowHelper }, { type: StoragePersistenceService }, { type: JsrsAsignReducedService }]; } });

    var CodeFlowCallbackHandlerService = /** @class */ (function () {
        function CodeFlowCallbackHandlerService(urlService, loggerService, tokenValidationService, flowsDataService, configurationProvider, storagePersistenceService, dataService) {
            this.urlService = urlService;
            this.loggerService = loggerService;
            this.tokenValidationService = tokenValidationService;
            this.flowsDataService = flowsDataService;
            this.configurationProvider = configurationProvider;
            this.storagePersistenceService = storagePersistenceService;
            this.dataService = dataService;
        }
        // STEP 1 Code Flow
        CodeFlowCallbackHandlerService.prototype.codeFlowCallback = function (urlToCheck, configId) {
            var code = this.urlService.getUrlParameter(urlToCheck, 'code');
            var state = this.urlService.getUrlParameter(urlToCheck, 'state');
            var sessionState = this.urlService.getUrlParameter(urlToCheck, 'session_state');
            if (!state) {
                this.loggerService.logDebug(configId, 'no state in url');
                return rxjs.throwError('no state in url');
            }
            if (!code) {
                this.loggerService.logDebug(configId, 'no code in url');
                return rxjs.throwError('no code in url');
            }
            this.loggerService.logDebug(configId, 'running validation for callback', urlToCheck);
            var initialCallbackContext = {
                code: code,
                refreshToken: null,
                state: state,
                sessionState: sessionState,
                authResult: null,
                isRenewProcess: false,
                jwtKeys: null,
                validationResult: null,
                existingIdToken: null,
            };
            return rxjs.of(initialCallbackContext);
        };
        // STEP 2 Code Flow //  Code Flow Silent Renew starts here
        CodeFlowCallbackHandlerService.prototype.codeFlowCodeRequest = function (callbackContext, configId) {
            var _this = this;
            var authStateControl = this.flowsDataService.getAuthStateControl(configId);
            var isStateCorrect = this.tokenValidationService.validateStateFromHashCallback(callbackContext.state, authStateControl, configId);
            if (!isStateCorrect) {
                return rxjs.throwError('codeFlowCodeRequest incorrect state');
            }
            var authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            var tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;
            if (!tokenEndpoint) {
                return rxjs.throwError('Token Endpoint not defined');
            }
            var headers = new i1.HttpHeaders();
            headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');
            var config = this.configurationProvider.getOpenIDConfiguration(configId);
            var bodyForCodeFlow = this.urlService.createBodyForCodeFlowCodeRequest(callbackContext.code, configId, config === null || config === void 0 ? void 0 : config.customParamsCodeRequest);
            return this.dataService.post(tokenEndpoint, bodyForCodeFlow, configId, headers).pipe(operators.switchMap(function (response) {
                var authResult = new Object();
                authResult = response;
                authResult.state = callbackContext.state;
                authResult.session_state = callbackContext.sessionState;
                callbackContext.authResult = authResult;
                return rxjs.of(callbackContext);
            }), operators.retryWhen(function (error) { return _this.handleRefreshRetry(error, configId); }), operators.catchError(function (error) {
                var authority = _this.configurationProvider.getOpenIDConfiguration(configId).authority;
                var errorMessage = "OidcService code request " + authority;
                _this.loggerService.logError(configId, errorMessage, error);
                return rxjs.throwError(errorMessage);
            }));
        };
        CodeFlowCallbackHandlerService.prototype.handleRefreshRetry = function (errors, configId) {
            var _this = this;
            return errors.pipe(operators.mergeMap(function (error) {
                // retry token refresh if there is no internet connection
                if (error && error instanceof i1.HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {
                    var _a = _this.configurationProvider.getOpenIDConfiguration(configId), authority = _a.authority, refreshTokenRetryInSeconds = _a.refreshTokenRetryInSeconds;
                    var errorMessage = "OidcService code request " + authority + " - no internet connection";
                    _this.loggerService.logWarning(configId, errorMessage, error);
                    return rxjs.timer(refreshTokenRetryInSeconds * 1000);
                }
                return rxjs.throwError(error);
            }));
        };
        return CodeFlowCallbackHandlerService;
    }());
    CodeFlowCallbackHandlerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CodeFlowCallbackHandlerService, deps: [{ token: UrlService }, { token: LoggerService }, { token: TokenValidationService }, { token: FlowsDataService }, { token: ConfigurationProvider }, { token: StoragePersistenceService }, { token: DataService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CodeFlowCallbackHandlerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CodeFlowCallbackHandlerService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CodeFlowCallbackHandlerService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: UrlService }, { type: LoggerService }, { type: TokenValidationService }, { type: FlowsDataService }, { type: ConfigurationProvider }, { type: StoragePersistenceService }, { type: DataService }]; } });

    var DEFAULT_USERRESULT = { userData: null, allUserData: [] };
    var UserService = /** @class */ (function () {
        function UserService(oidcDataService, storagePersistenceService, eventService, loggerService, tokenHelperService, flowHelper, configurationProvider) {
            this.oidcDataService = oidcDataService;
            this.storagePersistenceService = storagePersistenceService;
            this.eventService = eventService;
            this.loggerService = loggerService;
            this.tokenHelperService = tokenHelperService;
            this.flowHelper = flowHelper;
            this.configurationProvider = configurationProvider;
            this.userDataInternal$ = new rxjs.BehaviorSubject(DEFAULT_USERRESULT);
        }
        Object.defineProperty(UserService.prototype, "userData$", {
            get: function () {
                return this.userDataInternal$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        UserService.prototype.getAndPersistUserDataInStore = function (configId, isRenewProcess, idToken, decodedIdToken) {
            var _this = this;
            if (isRenewProcess === void 0) { isRenewProcess = false; }
            idToken = idToken || this.storagePersistenceService.getIdToken(configId);
            decodedIdToken = decodedIdToken || this.tokenHelperService.getPayloadFromToken(idToken, false, configId);
            var existingUserDataFromStorage = this.getUserDataFromStore(configId);
            var haveUserData = !!existingUserDataFromStorage;
            var isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);
            var isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);
            var accessToken = this.storagePersistenceService.getAccessToken(configId);
            if (!(isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow)) {
                this.loggerService.logDebug(configId, "authCallback idToken flow with accessToken " + accessToken);
                this.setUserDataToStore(decodedIdToken, configId);
                return rxjs.of(decodedIdToken);
            }
            var renewUserInfoAfterTokenRenew = this.configurationProvider.getOpenIDConfiguration(configId).renewUserInfoAfterTokenRenew;
            if (!isRenewProcess || renewUserInfoAfterTokenRenew || !haveUserData) {
                return this.getUserDataOidcFlowAndSave(decodedIdToken.sub, configId).pipe(operators.switchMap(function (userData) {
                    _this.loggerService.logDebug(configId, 'Received user data: ', userData);
                    if (!!userData) {
                        _this.loggerService.logDebug(configId, 'accessToken: ', accessToken);
                        return rxjs.of(userData);
                    }
                    else {
                        return rxjs.throwError('Received no user data, request failed');
                    }
                }));
            }
            return rxjs.of(existingUserDataFromStorage);
        };
        UserService.prototype.getUserDataFromStore = function (configId) {
            return this.storagePersistenceService.read('userData', configId) || null;
        };
        UserService.prototype.publishUserDataIfExists = function (configId) {
            var userData = this.getUserDataFromStore(configId);
            if (userData) {
                this.fireUserDataEvent(configId, userData);
            }
        };
        UserService.prototype.setUserDataToStore = function (userData, configId) {
            this.storagePersistenceService.write('userData', userData, configId);
            this.fireUserDataEvent(configId, userData);
        };
        UserService.prototype.resetUserDataInStore = function (configId) {
            this.storagePersistenceService.remove('userData', configId);
            this.fireUserDataEvent(configId, null);
        };
        UserService.prototype.getUserDataOidcFlowAndSave = function (idTokenSub, configId) {
            var _this = this;
            return this.getIdentityUserData(configId).pipe(operators.map(function (data) {
                if (_this.validateUserDataSubIdToken(idTokenSub, data === null || data === void 0 ? void 0 : data.sub)) {
                    _this.setUserDataToStore(data, configId);
                    return data;
                }
                else {
                    // something went wrong, user data sub does not match that from id_token
                    _this.loggerService.logWarning(configId, "User data sub does not match sub in id_token, resetting");
                    _this.resetUserDataInStore(configId);
                    return null;
                }
            }));
        };
        UserService.prototype.getIdentityUserData = function (configId) {
            var token = this.storagePersistenceService.getAccessToken(configId);
            var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            if (!authWellKnownEndPoints) {
                this.loggerService.logWarning(configId, 'init check session: authWellKnownEndpoints is undefined');
                return rxjs.throwError('authWellKnownEndpoints is undefined');
            }
            var userInfoEndpoint = authWellKnownEndPoints.userInfoEndpoint;
            if (!userInfoEndpoint) {
                this.loggerService.logError(configId, 'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config');
                return rxjs.throwError('authWellKnownEndpoints.userinfo_endpoint is undefined');
            }
            return this.oidcDataService.get(userInfoEndpoint, configId, token).pipe(operators.retry(2));
        };
        UserService.prototype.validateUserDataSubIdToken = function (idTokenSub, userDataSub) {
            if (!idTokenSub) {
                return false;
            }
            if (!userDataSub) {
                return false;
            }
            if (idTokenSub !== userDataSub) {
                this.loggerService.logDebug('validateUserDataSubIdToken failed', idTokenSub, userDataSub);
                return false;
            }
            return true;
        };
        UserService.prototype.fireUserDataEvent = function (configId, passedUserData) {
            var userData = this.composeSingleOrMultipleUserDataObject(configId, passedUserData);
            this.userDataInternal$.next(userData);
            this.eventService.fireEvent(exports.EventTypes.UserDataChanged, { configId: configId, userData: passedUserData });
        };
        UserService.prototype.composeSingleOrMultipleUserDataObject = function (configId, passedUserData) {
            var _this = this;
            var hasManyConfigs = this.configurationProvider.hasManyConfigs();
            if (!hasManyConfigs) {
                return this.composeSingleUserDataResult(configId, passedUserData);
            }
            var configs = this.configurationProvider.getAllConfigurations();
            var allUserData = configs.map(function (config) {
                if (_this.currentConfigIsToUpdate(configId, config)) {
                    return { configId: config.configId, userData: passedUserData };
                }
                var alreadySavedUserData = _this.storagePersistenceService.read('userData', config.configId) || null;
                return { configId: config.configId, userData: alreadySavedUserData };
            });
            return {
                userData: null,
                allUserData: allUserData,
            };
        };
        UserService.prototype.composeSingleUserDataResult = function (configId, userData) {
            return {
                userData: userData,
                allUserData: [{ configId: configId, userData: userData }],
            };
        };
        UserService.prototype.currentConfigIsToUpdate = function (configId, config) {
            return config.configId === configId;
        };
        return UserService;
    }());
    UserService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: UserService, deps: [{ token: DataService }, { token: StoragePersistenceService }, { token: PublicEventsService }, { token: LoggerService }, { token: TokenHelperService }, { token: FlowHelper }, { token: ConfigurationProvider }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: UserService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: UserService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: DataService }, { type: StoragePersistenceService }, { type: PublicEventsService }, { type: LoggerService }, { type: TokenHelperService }, { type: FlowHelper }, { type: ConfigurationProvider }]; } });

    var ResetAuthDataService = /** @class */ (function () {
        function ResetAuthDataService(authStateService, flowsDataService, userService) {
            this.authStateService = authStateService;
            this.flowsDataService = flowsDataService;
            this.userService = userService;
        }
        ResetAuthDataService.prototype.resetAuthorizationData = function (configId) {
            this.userService.resetUserDataInStore(configId);
            this.flowsDataService.resetStorageFlowData(configId);
            this.authStateService.setUnauthenticatedAndFireEvent(configId);
        };
        return ResetAuthDataService;
    }());
    ResetAuthDataService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ResetAuthDataService, deps: [{ token: AuthStateService }, { token: FlowsDataService }, { token: UserService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ResetAuthDataService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ResetAuthDataService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ResetAuthDataService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: AuthStateService }, { type: FlowsDataService }, { type: UserService }]; } });

    var ImplicitFlowCallbackHandlerService = /** @class */ (function () {
        function ImplicitFlowCallbackHandlerService(resetAuthDataService, loggerService, flowsDataService, doc) {
            this.resetAuthDataService = resetAuthDataService;
            this.loggerService = loggerService;
            this.flowsDataService = flowsDataService;
            this.doc = doc;
        }
        // STEP 1 Code Flow
        // STEP 1 Implicit Flow
        ImplicitFlowCallbackHandlerService.prototype.implicitFlowCallback = function (configId, hash) {
            var isRenewProcessData = this.flowsDataService.isSilentRenewRunning(configId);
            this.loggerService.logDebug(configId, 'BEGIN callback, no auth data');
            if (!isRenewProcessData) {
                this.resetAuthDataService.resetAuthorizationData(configId);
            }
            hash = hash || this.doc.location.hash.substr(1);
            var authResult = hash.split('&').reduce(function (resultData, item) {
                var parts = item.split('=');
                resultData[parts.shift()] = parts.join('=');
                return resultData;
            }, {});
            var callbackContext = {
                code: null,
                refreshToken: null,
                state: null,
                sessionState: null,
                authResult: authResult,
                isRenewProcess: isRenewProcessData,
                jwtKeys: null,
                validationResult: null,
                existingIdToken: null,
            };
            return rxjs.of(callbackContext);
        };
        return ImplicitFlowCallbackHandlerService;
    }());
    ImplicitFlowCallbackHandlerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ImplicitFlowCallbackHandlerService, deps: [{ token: ResetAuthDataService }, { token: LoggerService }, { token: FlowsDataService }, { token: common.DOCUMENT }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ImplicitFlowCallbackHandlerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ImplicitFlowCallbackHandlerService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ImplicitFlowCallbackHandlerService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: ResetAuthDataService }, { type: LoggerService }, { type: FlowsDataService }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [common.DOCUMENT]
                        }] }];
        } });

    /* eslint-disable no-shadow */
    exports.ValidationResult = void 0;
    (function (ValidationResult) {
        ValidationResult["NotSet"] = "NotSet";
        ValidationResult["StatesDoNotMatch"] = "StatesDoNotMatch";
        ValidationResult["SignatureFailed"] = "SignatureFailed";
        ValidationResult["IncorrectNonce"] = "IncorrectNonce";
        ValidationResult["RequiredPropertyMissing"] = "RequiredPropertyMissing";
        ValidationResult["MaxOffsetExpired"] = "MaxOffsetExpired";
        ValidationResult["IssDoesNotMatchIssuer"] = "IssDoesNotMatchIssuer";
        ValidationResult["NoAuthWellKnownEndPoints"] = "NoAuthWellKnownEndPoints";
        ValidationResult["IncorrectAud"] = "IncorrectAud";
        ValidationResult["IncorrectIdTokenClaimsAfterRefresh"] = "IncorrectIdTokenClaimsAfterRefresh";
        ValidationResult["IncorrectAzp"] = "IncorrectAzp";
        ValidationResult["TokenExpired"] = "TokenExpired";
        ValidationResult["IncorrectAtHash"] = "IncorrectAtHash";
        ValidationResult["Ok"] = "Ok";
        ValidationResult["LoginRequired"] = "LoginRequired";
        ValidationResult["SecureTokenServerError"] = "SecureTokenServerError";
    })(exports.ValidationResult || (exports.ValidationResult = {}));

    var SigninKeyDataService = /** @class */ (function () {
        function SigninKeyDataService(storagePersistenceService, loggerService, dataService) {
            this.storagePersistenceService = storagePersistenceService;
            this.loggerService = loggerService;
            this.dataService = dataService;
        }
        SigninKeyDataService.prototype.getSigningKeys = function (configId) {
            var _this = this;
            var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            var jwksUri = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.jwksUri;
            if (!jwksUri) {
                var error = "getSigningKeys: authWellKnownEndpoints.jwksUri is: '" + jwksUri + "'";
                this.loggerService.logWarning(configId, error);
                return rxjs.throwError(error);
            }
            this.loggerService.logDebug(configId, 'Getting signinkeys from ', jwksUri);
            return this.dataService.get(jwksUri, configId).pipe(operators.retry(2), operators.catchError(function (e) { return _this.handleErrorGetSigningKeys(e, configId); }));
        };
        SigninKeyDataService.prototype.handleErrorGetSigningKeys = function (errorResponse, configId) {
            var errMsg = '';
            if (errorResponse instanceof i1.HttpResponse) {
                var body = errorResponse.body || {};
                var err = JSON.stringify(body);
                var status = errorResponse.status, statusText = errorResponse.statusText;
                errMsg = (status || '') + " - " + (statusText || '') + " " + (err || '');
            }
            else {
                var message = errorResponse.message;
                errMsg = !!message ? message : "" + errorResponse;
            }
            this.loggerService.logError(configId, errMsg);
            return rxjs.throwError(errMsg);
        };
        return SigninKeyDataService;
    }());
    SigninKeyDataService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: SigninKeyDataService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: DataService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SigninKeyDataService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: SigninKeyDataService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: SigninKeyDataService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: DataService }]; } });

    var JWT_KEYS = 'jwtKeys';
    var HistoryJwtKeysCallbackHandlerService = /** @class */ (function () {
        function HistoryJwtKeysCallbackHandlerService(loggerService, configurationProvider, authStateService, flowsDataService, signInKeyDataService, storagePersistenceService, resetAuthDataService) {
            this.loggerService = loggerService;
            this.configurationProvider = configurationProvider;
            this.authStateService = authStateService;
            this.flowsDataService = flowsDataService;
            this.signInKeyDataService = signInKeyDataService;
            this.storagePersistenceService = storagePersistenceService;
            this.resetAuthDataService = resetAuthDataService;
        }
        // STEP 3 Code Flow, STEP 2 Implicit Flow, STEP 3 Refresh Token
        HistoryJwtKeysCallbackHandlerService.prototype.callbackHistoryAndResetJwtKeys = function (callbackContext, configId) {
            var _this = this;
            this.storagePersistenceService.write('authnResult', callbackContext.authResult, configId);
            if (this.historyCleanUpTurnedOn(configId) && !callbackContext.isRenewProcess) {
                this.resetBrowserHistory();
            }
            else {
                this.loggerService.logDebug(configId, 'history clean up inactive');
            }
            if (callbackContext.authResult.error) {
                var errorMessage = "AuthCallback AuthResult came with error: " + callbackContext.authResult.error;
                this.loggerService.logDebug(configId, errorMessage);
                this.resetAuthDataService.resetAuthorizationData(configId);
                this.flowsDataService.setNonce('', configId);
                this.handleResultErrorFromCallback(callbackContext.authResult, callbackContext.isRenewProcess);
                return rxjs.throwError(errorMessage);
            }
            this.loggerService.logDebug(configId, "AuthResult '" + JSON.stringify(callbackContext.authResult, null, 2) + "'.\n      AuthCallback created, begin token validation");
            return this.signInKeyDataService.getSigningKeys(configId).pipe(operators.tap(function (jwtKeys) { return _this.storeSigningKeys(jwtKeys, configId); }), operators.catchError(function (err) {
                // fallback: try to load jwtKeys from storage
                var storedJwtKeys = _this.readSigningKeys(configId);
                if (!!storedJwtKeys) {
                    _this.loggerService.logWarning(configId, "Failed to retrieve signing keys, fallback to stored keys");
                    return rxjs.of(storedJwtKeys);
                }
                return rxjs.throwError(err);
            }), operators.switchMap(function (jwtKeys) {
                if (jwtKeys) {
                    callbackContext.jwtKeys = jwtKeys;
                    return rxjs.of(callbackContext);
                }
                var errorMessage = "Failed to retrieve signing key";
                _this.loggerService.logWarning(configId, errorMessage);
                return rxjs.throwError(errorMessage);
            }), operators.catchError(function (err) {
                var errorMessage = "Failed to retrieve signing key with error: " + err;
                _this.loggerService.logWarning(configId, errorMessage);
                return rxjs.throwError(errorMessage);
            }));
        };
        HistoryJwtKeysCallbackHandlerService.prototype.handleResultErrorFromCallback = function (result, isRenewProcess) {
            var validationResult = exports.ValidationResult.SecureTokenServerError;
            if (result.error === 'login_required') {
                validationResult = exports.ValidationResult.LoginRequired;
            }
            this.authStateService.updateAndPublishAuthState({
                isAuthenticated: false,
                validationResult: validationResult,
                isRenewProcess: isRenewProcess,
            });
        };
        HistoryJwtKeysCallbackHandlerService.prototype.historyCleanUpTurnedOn = function (configId) {
            var historyCleanupOff = this.configurationProvider.getOpenIDConfiguration(configId).historyCleanupOff;
            return !historyCleanupOff;
        };
        HistoryJwtKeysCallbackHandlerService.prototype.resetBrowserHistory = function () {
            window.history.replaceState({}, window.document.title, window.location.origin + window.location.pathname);
        };
        HistoryJwtKeysCallbackHandlerService.prototype.storeSigningKeys = function (jwtKeys, configId) {
            this.storagePersistenceService.write(JWT_KEYS, jwtKeys, configId);
        };
        HistoryJwtKeysCallbackHandlerService.prototype.readSigningKeys = function (configId) {
            return this.storagePersistenceService.read(JWT_KEYS, configId);
        };
        return HistoryJwtKeysCallbackHandlerService;
    }());
    HistoryJwtKeysCallbackHandlerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: HistoryJwtKeysCallbackHandlerService, deps: [{ token: LoggerService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: FlowsDataService }, { token: SigninKeyDataService }, { token: StoragePersistenceService }, { token: ResetAuthDataService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    HistoryJwtKeysCallbackHandlerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: HistoryJwtKeysCallbackHandlerService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: HistoryJwtKeysCallbackHandlerService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: LoggerService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: FlowsDataService }, { type: SigninKeyDataService }, { type: StoragePersistenceService }, { type: ResetAuthDataService }]; } });

    var UserCallbackHandlerService = /** @class */ (function () {
        function UserCallbackHandlerService(loggerService, configurationProvider, authStateService, flowsDataService, userService, resetAuthDataService) {
            this.loggerService = loggerService;
            this.configurationProvider = configurationProvider;
            this.authStateService = authStateService;
            this.flowsDataService = flowsDataService;
            this.userService = userService;
            this.resetAuthDataService = resetAuthDataService;
        }
        // STEP 5 userData
        UserCallbackHandlerService.prototype.callbackUser = function (callbackContext, configId) {
            var _this = this;
            var isRenewProcess = callbackContext.isRenewProcess, validationResult = callbackContext.validationResult, authResult = callbackContext.authResult, refreshToken = callbackContext.refreshToken;
            var _a = this.configurationProvider.getOpenIDConfiguration(configId), autoUserInfo = _a.autoUserInfo, renewUserInfoAfterTokenRenew = _a.renewUserInfoAfterTokenRenew;
            if (!autoUserInfo) {
                if (!isRenewProcess || renewUserInfoAfterTokenRenew) {
                    // userData is set to the id_token decoded, auto get user data set to false
                    if (validationResult.decodedIdToken) {
                        this.userService.setUserDataToStore(validationResult.decodedIdToken, configId);
                    }
                }
                if (!isRenewProcess && !refreshToken) {
                    this.flowsDataService.setSessionState(authResult.session_state, configId);
                }
                this.publishAuthState(validationResult, isRenewProcess);
                return rxjs.of(callbackContext);
            }
            return this.userService
                .getAndPersistUserDataInStore(configId, isRenewProcess, validationResult.idToken, validationResult.decodedIdToken)
                .pipe(operators.switchMap(function (userData) {
                if (!!userData) {
                    if (!refreshToken) {
                        _this.flowsDataService.setSessionState(authResult.session_state, configId);
                    }
                    _this.publishAuthState(validationResult, isRenewProcess);
                    return rxjs.of(callbackContext);
                }
                else {
                    _this.resetAuthDataService.resetAuthorizationData(configId);
                    _this.publishUnauthenticatedState(validationResult, isRenewProcess);
                    var errorMessage = "Called for userData but they were " + userData;
                    _this.loggerService.logWarning(configId, errorMessage);
                    return rxjs.throwError(errorMessage);
                }
            }), operators.catchError(function (err) {
                var errorMessage = "Failed to retrieve user info with error:  " + err;
                _this.loggerService.logWarning(configId, errorMessage);
                return rxjs.throwError(errorMessage);
            }));
        };
        UserCallbackHandlerService.prototype.publishAuthState = function (stateValidationResult, isRenewProcess) {
            this.authStateService.updateAndPublishAuthState({
                isAuthenticated: true,
                validationResult: stateValidationResult.state,
                isRenewProcess: isRenewProcess,
            });
        };
        UserCallbackHandlerService.prototype.publishUnauthenticatedState = function (stateValidationResult, isRenewProcess) {
            this.authStateService.updateAndPublishAuthState({
                isAuthenticated: false,
                validationResult: stateValidationResult.state,
                isRenewProcess: isRenewProcess,
            });
        };
        return UserCallbackHandlerService;
    }());
    UserCallbackHandlerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: UserCallbackHandlerService, deps: [{ token: LoggerService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: FlowsDataService }, { token: UserService }, { token: ResetAuthDataService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UserCallbackHandlerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: UserCallbackHandlerService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: UserCallbackHandlerService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: LoggerService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: FlowsDataService }, { type: UserService }, { type: ResetAuthDataService }]; } });

    var StateValidationResult = /** @class */ (function () {
        function StateValidationResult(accessToken, idToken, authResponseIsValid, decodedIdToken, state) {
            if (accessToken === void 0) { accessToken = ''; }
            if (idToken === void 0) { idToken = ''; }
            if (authResponseIsValid === void 0) { authResponseIsValid = false; }
            if (decodedIdToken === void 0) { decodedIdToken = {}; }
            if (state === void 0) { state = exports.ValidationResult.NotSet; }
            this.accessToken = accessToken;
            this.idToken = idToken;
            this.authResponseIsValid = authResponseIsValid;
            this.decodedIdToken = decodedIdToken;
            this.state = state;
        }
        return StateValidationResult;
    }());

    var EqualityService = /** @class */ (function () {
        function EqualityService() {
        }
        EqualityService.prototype.isStringEqualOrNonOrderedArrayEqual = function (value1, value2) {
            if (this.isNullOrUndefined(value1)) {
                return false;
            }
            if (this.isNullOrUndefined(value2)) {
                return false;
            }
            if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {
                return false;
            }
            if (this.bothValuesAreStrings(value1, value2)) {
                return value1 === value2;
            }
            if (this.bothValuesAreArrays(value1, value2)) {
                return this.arraysHaveEqualContent(value1, value2);
            }
            return false;
        };
        EqualityService.prototype.areEqual = function (value1, value2) {
            if (!value1 || !value2) {
                return false;
            }
            if (this.bothValuesAreArrays(value1, value2)) {
                return this.arraysStrictEqual(value1, value2);
            }
            if (this.bothValuesAreStrings(value1, value2)) {
                return value1 === value2;
            }
            if (this.bothValuesAreObjects(value1, value2)) {
                return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();
            }
            if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {
                if (Array.isArray(value1) && this.valueIsString(value2)) {
                    return value1[0] === value2;
                }
                if (Array.isArray(value2) && this.valueIsString(value1)) {
                    return value2[0] === value1;
                }
            }
            return false;
        };
        EqualityService.prototype.oneValueIsStringAndTheOtherIsArray = function (value1, value2) {
            return (Array.isArray(value1) && this.valueIsString(value2)) || (Array.isArray(value2) && this.valueIsString(value1));
        };
        EqualityService.prototype.bothValuesAreObjects = function (value1, value2) {
            return this.valueIsObject(value1) && this.valueIsObject(value2);
        };
        EqualityService.prototype.bothValuesAreStrings = function (value1, value2) {
            return this.valueIsString(value1) && this.valueIsString(value2);
        };
        EqualityService.prototype.bothValuesAreArrays = function (value1, value2) {
            return Array.isArray(value1) && Array.isArray(value2);
        };
        EqualityService.prototype.valueIsString = function (value) {
            return typeof value === 'string' || value instanceof String;
        };
        EqualityService.prototype.valueIsObject = function (value) {
            return typeof value === 'object';
        };
        EqualityService.prototype.arraysStrictEqual = function (arr1, arr2) {
            if (arr1.length !== arr2.length) {
                return false;
            }
            for (var i = arr1.length; i--;) {
                if (arr1[i] !== arr2[i]) {
                    return false;
                }
            }
            return true;
        };
        EqualityService.prototype.arraysHaveEqualContent = function (arr1, arr2) {
            if (arr1.length !== arr2.length) {
                return false;
            }
            return arr1.some(function (v) { return arr2.includes(v); });
        };
        EqualityService.prototype.isNullOrUndefined = function (val) {
            return val === null || val === undefined;
        };
        return EqualityService;
    }());
    EqualityService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: EqualityService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    EqualityService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: EqualityService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: EqualityService, decorators: [{
                type: i0.Injectable
            }] });

    var StateValidationService = /** @class */ (function () {
        function StateValidationService(storagePersistenceService, tokenValidationService, tokenHelperService, loggerService, configurationProvider, equalityService, flowHelper) {
            this.storagePersistenceService = storagePersistenceService;
            this.tokenValidationService = tokenValidationService;
            this.tokenHelperService = tokenHelperService;
            this.loggerService = loggerService;
            this.configurationProvider = configurationProvider;
            this.equalityService = equalityService;
            this.flowHelper = flowHelper;
        }
        StateValidationService.prototype.getValidatedStateResult = function (callbackContext, configId) {
            if (!callbackContext) {
                return new StateValidationResult('', '', false, {});
            }
            if (callbackContext.authResult.error) {
                return new StateValidationResult('', '', false, {});
            }
            return this.validateState(callbackContext, configId);
        };
        StateValidationService.prototype.validateState = function (callbackContext, configId) {
            var toReturn = new StateValidationResult();
            var authStateControl = this.storagePersistenceService.read('authStateControl', configId);
            if (!this.tokenValidationService.validateStateFromHashCallback(callbackContext.authResult.state, authStateControl, configId)) {
                this.loggerService.logWarning(configId, 'authCallback incorrect state');
                toReturn.state = exports.ValidationResult.StatesDoNotMatch;
                this.handleUnsuccessfulValidation(configId);
                return toReturn;
            }
            var isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);
            var isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);
            if (isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow) {
                toReturn.accessToken = callbackContext.authResult.access_token;
            }
            if (callbackContext.authResult.id_token) {
                var _a = this.configurationProvider.getOpenIDConfiguration(configId), clientId = _a.clientId, issValidationOff = _a.issValidationOff, maxIdTokenIatOffsetAllowedInSeconds = _a.maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation = _a.disableIatOffsetValidation, ignoreNonceAfterRefresh = _a.ignoreNonceAfterRefresh;
                toReturn.idToken = callbackContext.authResult.id_token;
                toReturn.decodedIdToken = this.tokenHelperService.getPayloadFromToken(toReturn.idToken, false, configId);
                if (!this.tokenValidationService.validateSignatureIdToken(toReturn.idToken, callbackContext.jwtKeys, configId)) {
                    this.loggerService.logDebug(configId, 'authCallback Signature validation failed id_token');
                    toReturn.state = exports.ValidationResult.SignatureFailed;
                    this.handleUnsuccessfulValidation(configId);
                    return toReturn;
                }
                var authNonce = this.storagePersistenceService.read('authNonce', configId);
                if (!this.tokenValidationService.validateIdTokenNonce(toReturn.decodedIdToken, authNonce, ignoreNonceAfterRefresh, configId)) {
                    this.loggerService.logWarning(configId, 'authCallback incorrect nonce, did you call the checkAuth() method multiple times?');
                    toReturn.state = exports.ValidationResult.IncorrectNonce;
                    this.handleUnsuccessfulValidation(configId);
                    return toReturn;
                }
                if (!this.tokenValidationService.validateRequiredIdToken(toReturn.decodedIdToken, configId)) {
                    this.loggerService.logDebug(configId, 'authCallback Validation, one of the REQUIRED properties missing from id_token');
                    toReturn.state = exports.ValidationResult.RequiredPropertyMissing;
                    this.handleUnsuccessfulValidation(configId);
                    return toReturn;
                }
                if (!this.tokenValidationService.validateIdTokenIatMaxOffset(toReturn.decodedIdToken, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, configId)) {
                    this.loggerService.logWarning(configId, 'authCallback Validation, iat rejected id_token was issued too far away from the current time');
                    toReturn.state = exports.ValidationResult.MaxOffsetExpired;
                    this.handleUnsuccessfulValidation(configId);
                    return toReturn;
                }
                var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
                if (authWellKnownEndPoints) {
                    if (issValidationOff) {
                        this.loggerService.logDebug(configId, 'iss validation is turned off, this is not recommended!');
                    }
                    else if (!issValidationOff &&
                        !this.tokenValidationService.validateIdTokenIss(toReturn.decodedIdToken, authWellKnownEndPoints.issuer, configId)) {
                        this.loggerService.logWarning(configId, 'authCallback incorrect iss does not match authWellKnownEndpoints issuer');
                        toReturn.state = exports.ValidationResult.IssDoesNotMatchIssuer;
                        this.handleUnsuccessfulValidation(configId);
                        return toReturn;
                    }
                }
                else {
                    this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');
                    toReturn.state = exports.ValidationResult.NoAuthWellKnownEndPoints;
                    this.handleUnsuccessfulValidation(configId);
                    return toReturn;
                }
                if (!this.tokenValidationService.validateIdTokenAud(toReturn.decodedIdToken, clientId, configId)) {
                    this.loggerService.logWarning(configId, 'authCallback incorrect aud');
                    toReturn.state = exports.ValidationResult.IncorrectAud;
                    this.handleUnsuccessfulValidation(configId);
                    return toReturn;
                }
                if (!this.tokenValidationService.validateIdTokenAzpExistsIfMoreThanOneAud(toReturn.decodedIdToken)) {
                    this.loggerService.logWarning(configId, 'authCallback missing azp');
                    toReturn.state = exports.ValidationResult.IncorrectAzp;
                    this.handleUnsuccessfulValidation(configId);
                    return toReturn;
                }
                if (!this.tokenValidationService.validateIdTokenAzpValid(toReturn.decodedIdToken, clientId)) {
                    this.loggerService.logWarning(configId, 'authCallback incorrect azp');
                    toReturn.state = exports.ValidationResult.IncorrectAzp;
                    this.handleUnsuccessfulValidation(configId);
                    return toReturn;
                }
                if (!this.isIdTokenAfterRefreshTokenRequestValid(callbackContext, toReturn.decodedIdToken, configId)) {
                    this.loggerService.logWarning(configId, 'authCallback pre, post id_token claims do not match in refresh');
                    toReturn.state = exports.ValidationResult.IncorrectIdTokenClaimsAfterRefresh;
                    this.handleUnsuccessfulValidation(configId);
                    return toReturn;
                }
                if (!this.tokenValidationService.validateIdTokenExpNotExpired(toReturn.decodedIdToken, configId)) {
                    this.loggerService.logWarning(configId, 'authCallback id token expired');
                    toReturn.state = exports.ValidationResult.TokenExpired;
                    this.handleUnsuccessfulValidation(configId);
                    return toReturn;
                }
            }
            else {
                this.loggerService.logDebug(configId, 'No id_token found, skipping id_token validation');
            }
            // flow id_token
            if (!isCurrentFlowImplicitFlowWithAccessToken && !isCurrentFlowCodeFlow) {
                toReturn.authResponseIsValid = true;
                toReturn.state = exports.ValidationResult.Ok;
                this.handleSuccessfulValidation(configId);
                this.handleUnsuccessfulValidation(configId);
                return toReturn;
            }
            // only do check if id_token returned, no always the case when using refresh tokens
            if (callbackContext.authResult.id_token) {
                var idTokenHeader = this.tokenHelperService.getHeaderFromToken(toReturn.idToken, false, configId);
                // The at_hash is optional for the code flow
                if (isCurrentFlowCodeFlow && !toReturn.decodedIdToken.at_hash) {
                    this.loggerService.logDebug(configId, 'Code Flow active, and no at_hash in the id_token, skipping check!');
                }
                else if (!this.tokenValidationService.validateIdTokenAtHash(toReturn.accessToken, toReturn.decodedIdToken.at_hash, idTokenHeader.alg, // 'RSA256'
                configId) ||
                    !toReturn.accessToken) {
                    this.loggerService.logWarning(configId, 'authCallback incorrect at_hash');
                    toReturn.state = exports.ValidationResult.IncorrectAtHash;
                    this.handleUnsuccessfulValidation(configId);
                    return toReturn;
                }
            }
            toReturn.authResponseIsValid = true;
            toReturn.state = exports.ValidationResult.Ok;
            this.handleSuccessfulValidation(configId);
            return toReturn;
        };
        StateValidationService.prototype.isIdTokenAfterRefreshTokenRequestValid = function (callbackContext, newIdToken, configId) {
            var _a = this.configurationProvider.getOpenIDConfiguration(configId), useRefreshToken = _a.useRefreshToken, disableRefreshIdTokenAuthTimeValidation = _a.disableRefreshIdTokenAuthTimeValidation;
            if (!useRefreshToken) {
                return true;
            }
            if (!callbackContext.existingIdToken) {
                return true;
            }
            var decodedIdToken = this.tokenHelperService.getPayloadFromToken(callbackContext.existingIdToken, false, configId);
            // Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3
            // except that it might not contain an id_token.
            // If an ID Token is returned as a result of a token refresh request, the following requirements apply:
            // its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,
            if (decodedIdToken.iss !== newIdToken.iss) {
                this.loggerService.logDebug(configId, "iss do not match: " + decodedIdToken.iss + " " + newIdToken.iss);
                return false;
            }
            // its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred;
            //   if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token, and
            // otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.
            if (decodedIdToken.azp !== newIdToken.azp) {
                this.loggerService.logDebug(configId, "azp do not match: " + decodedIdToken.azp + " " + newIdToken.azp);
                return false;
            }
            // its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,
            if (decodedIdToken.sub !== newIdToken.sub) {
                this.loggerService.logDebug(configId, "sub do not match: " + decodedIdToken.sub + " " + newIdToken.sub);
                return false;
            }
            // its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,
            if (!this.equalityService.isStringEqualOrNonOrderedArrayEqual(decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud, newIdToken === null || newIdToken === void 0 ? void 0 : newIdToken.aud)) {
                this.loggerService.logDebug(configId, "aud in new id_token is not valid: '" + (decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud) + "' '" + newIdToken.aud + "'");
                return false;
            }
            if (disableRefreshIdTokenAuthTimeValidation) {
                return true;
            }
            // its iat Claim MUST represent the time that the new ID Token is issued,
            // if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication
            // - not the time that the new ID token is issued,
            if (decodedIdToken.auth_time !== newIdToken.auth_time) {
                this.loggerService.logDebug(configId, "auth_time do not match: " + decodedIdToken.auth_time + " " + newIdToken.auth_time);
                return false;
            }
            return true;
        };
        StateValidationService.prototype.handleSuccessfulValidation = function (configId) {
            var autoCleanStateAfterAuthentication = this.configurationProvider.getOpenIDConfiguration(configId).autoCleanStateAfterAuthentication;
            this.storagePersistenceService.write('authNonce', null, configId);
            if (autoCleanStateAfterAuthentication) {
                this.storagePersistenceService.write('authStateControl', '', configId);
            }
            this.loggerService.logDebug(configId, 'authCallback token(s) validated, continue');
        };
        StateValidationService.prototype.handleUnsuccessfulValidation = function (configId) {
            var autoCleanStateAfterAuthentication = this.configurationProvider.getOpenIDConfiguration(configId).autoCleanStateAfterAuthentication;
            this.storagePersistenceService.write('authNonce', null, configId);
            if (autoCleanStateAfterAuthentication) {
                this.storagePersistenceService.write('authStateControl', '', configId);
            }
            this.loggerService.logDebug(configId, 'authCallback token(s) invalid');
        };
        return StateValidationService;
    }());
    StateValidationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: StateValidationService, deps: [{ token: StoragePersistenceService }, { token: TokenValidationService }, { token: TokenHelperService }, { token: LoggerService }, { token: ConfigurationProvider }, { token: EqualityService }, { token: FlowHelper }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    StateValidationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: StateValidationService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: StateValidationService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: TokenValidationService }, { type: TokenHelperService }, { type: LoggerService }, { type: ConfigurationProvider }, { type: EqualityService }, { type: FlowHelper }]; } });

    var StateValidationCallbackHandlerService = /** @class */ (function () {
        function StateValidationCallbackHandlerService(loggerService, stateValidationService, authStateService, resetAuthDataService, doc) {
            this.loggerService = loggerService;
            this.stateValidationService = stateValidationService;
            this.authStateService = authStateService;
            this.resetAuthDataService = resetAuthDataService;
            this.doc = doc;
        }
        // STEP 4 All flows
        StateValidationCallbackHandlerService.prototype.callbackStateValidation = function (callbackContext, configId) {
            var validationResult = this.stateValidationService.getValidatedStateResult(callbackContext, configId);
            callbackContext.validationResult = validationResult;
            if (validationResult.authResponseIsValid) {
                this.authStateService.setAuthorizationData(validationResult.accessToken, callbackContext.authResult, configId);
                return rxjs.of(callbackContext);
            }
            else {
                var errorMessage = "authorizedCallback, token(s) validation failed, resetting. Hash: " + this.doc.location.hash;
                this.loggerService.logWarning(configId, errorMessage);
                this.resetAuthDataService.resetAuthorizationData(configId);
                this.publishUnauthorizedState(callbackContext.validationResult, callbackContext.isRenewProcess);
                return rxjs.throwError(errorMessage);
            }
        };
        StateValidationCallbackHandlerService.prototype.publishUnauthorizedState = function (stateValidationResult, isRenewProcess) {
            this.authStateService.updateAndPublishAuthState({
                isAuthenticated: false,
                validationResult: stateValidationResult.state,
                isRenewProcess: isRenewProcess,
            });
        };
        return StateValidationCallbackHandlerService;
    }());
    StateValidationCallbackHandlerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: StateValidationCallbackHandlerService, deps: [{ token: LoggerService }, { token: StateValidationService }, { token: AuthStateService }, { token: ResetAuthDataService }, { token: common.DOCUMENT }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    StateValidationCallbackHandlerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: StateValidationCallbackHandlerService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: StateValidationCallbackHandlerService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: LoggerService }, { type: StateValidationService }, { type: AuthStateService }, { type: ResetAuthDataService }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [common.DOCUMENT]
                        }] }];
        } });

    var RefreshSessionCallbackHandlerService = /** @class */ (function () {
        function RefreshSessionCallbackHandlerService(loggerService, authStateService, flowsDataService) {
            this.loggerService = loggerService;
            this.authStateService = authStateService;
            this.flowsDataService = flowsDataService;
        }
        // STEP 1 Refresh session
        RefreshSessionCallbackHandlerService.prototype.refreshSessionWithRefreshTokens = function (configId) {
            var stateData = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);
            this.loggerService.logDebug(configId, 'RefreshSession created. Adding myautostate: ' + stateData);
            var refreshToken = this.authStateService.getRefreshToken(configId);
            var idToken = this.authStateService.getIdToken(configId);
            if (refreshToken) {
                var callbackContext = {
                    code: null,
                    refreshToken: refreshToken,
                    state: stateData,
                    sessionState: null,
                    authResult: null,
                    isRenewProcess: true,
                    jwtKeys: null,
                    validationResult: null,
                    existingIdToken: idToken,
                };
                this.loggerService.logDebug(configId, 'found refresh code, obtaining new credentials with refresh code');
                // Nonce is not used with refresh tokens; but Key cloak may send it anyway
                this.flowsDataService.setNonce(TokenValidationService.refreshTokenNoncePlaceholder, configId);
                return rxjs.of(callbackContext);
            }
            else {
                var errorMessage = 'no refresh token found, please login';
                this.loggerService.logError(configId, errorMessage);
                return rxjs.throwError(errorMessage);
            }
        };
        return RefreshSessionCallbackHandlerService;
    }());
    RefreshSessionCallbackHandlerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshSessionCallbackHandlerService, deps: [{ token: LoggerService }, { token: AuthStateService }, { token: FlowsDataService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RefreshSessionCallbackHandlerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshSessionCallbackHandlerService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshSessionCallbackHandlerService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: LoggerService }, { type: AuthStateService }, { type: FlowsDataService }]; } });

    var RefreshTokenCallbackHandlerService = /** @class */ (function () {
        function RefreshTokenCallbackHandlerService(urlService, loggerService, configurationProvider, dataService, storagePersistenceService) {
            this.urlService = urlService;
            this.loggerService = loggerService;
            this.configurationProvider = configurationProvider;
            this.dataService = dataService;
            this.storagePersistenceService = storagePersistenceService;
        }
        // STEP 2 Refresh Token
        RefreshTokenCallbackHandlerService.prototype.refreshTokensRequestTokens = function (callbackContext, configId, customParamsRefresh) {
            var _this = this;
            var headers = new i1.HttpHeaders();
            headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');
            var authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            var tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;
            if (!tokenEndpoint) {
                return rxjs.throwError('Token Endpoint not defined');
            }
            var data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, configId, customParamsRefresh);
            return this.dataService.post(tokenEndpoint, data, configId, headers).pipe(operators.switchMap(function (response) {
                _this.loggerService.logDebug(configId, 'token refresh response: ', response);
                var authResult = new Object();
                authResult = response;
                authResult.state = callbackContext.state;
                callbackContext.authResult = authResult;
                return rxjs.of(callbackContext);
            }), operators.retryWhen(function (error) { return _this.handleRefreshRetry(error, configId); }), operators.catchError(function (error) {
                var authority = _this.configurationProvider.getOpenIDConfiguration(configId).authority;
                var errorMessage = "OidcService code request " + authority;
                _this.loggerService.logError(configId, errorMessage, error);
                return rxjs.throwError(errorMessage);
            }));
        };
        RefreshTokenCallbackHandlerService.prototype.handleRefreshRetry = function (errors, configId) {
            var _this = this;
            return errors.pipe(operators.mergeMap(function (error) {
                // retry token refresh if there is no internet connection
                if (error && error instanceof i1.HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {
                    var _a = _this.configurationProvider.getOpenIDConfiguration(configId), authority = _a.authority, refreshTokenRetryInSeconds = _a.refreshTokenRetryInSeconds;
                    var errorMessage = "OidcService code request " + authority + " - no internet connection";
                    _this.loggerService.logWarning(configId, errorMessage, error);
                    return rxjs.timer(refreshTokenRetryInSeconds * 1000);
                }
                return rxjs.throwError(error);
            }));
        };
        return RefreshTokenCallbackHandlerService;
    }());
    RefreshTokenCallbackHandlerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshTokenCallbackHandlerService, deps: [{ token: UrlService }, { token: LoggerService }, { token: ConfigurationProvider }, { token: DataService }, { token: StoragePersistenceService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RefreshTokenCallbackHandlerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshTokenCallbackHandlerService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshTokenCallbackHandlerService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: UrlService }, { type: LoggerService }, { type: ConfigurationProvider }, { type: DataService }, { type: StoragePersistenceService }]; } });

    var FlowsService = /** @class */ (function () {
        function FlowsService(codeFlowCallbackHandlerService, implicitFlowCallbackHandlerService, historyJwtKeysCallbackHandlerService, userHandlerService, stateValidationCallbackHandlerService, refreshSessionCallbackHandlerService, refreshTokenCallbackHandlerService) {
            this.codeFlowCallbackHandlerService = codeFlowCallbackHandlerService;
            this.implicitFlowCallbackHandlerService = implicitFlowCallbackHandlerService;
            this.historyJwtKeysCallbackHandlerService = historyJwtKeysCallbackHandlerService;
            this.userHandlerService = userHandlerService;
            this.stateValidationCallbackHandlerService = stateValidationCallbackHandlerService;
            this.refreshSessionCallbackHandlerService = refreshSessionCallbackHandlerService;
            this.refreshTokenCallbackHandlerService = refreshTokenCallbackHandlerService;
        }
        FlowsService.prototype.processCodeFlowCallback = function (urlToCheck, configId) {
            var _this = this;
            return this.codeFlowCallbackHandlerService.codeFlowCallback(urlToCheck, configId).pipe(operators.concatMap(function (callbackContext) { return _this.codeFlowCallbackHandlerService.codeFlowCodeRequest(callbackContext, configId); }), operators.concatMap(function (callbackContext) { return _this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId); }), operators.concatMap(function (callbackContext) { return _this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId); }), operators.concatMap(function (callbackContext) { return _this.userHandlerService.callbackUser(callbackContext, configId); }));
        };
        FlowsService.prototype.processSilentRenewCodeFlowCallback = function (firstContext, configId) {
            var _this = this;
            return this.codeFlowCallbackHandlerService.codeFlowCodeRequest(firstContext, configId).pipe(operators.concatMap(function (callbackContext) { return _this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId); }), operators.concatMap(function (callbackContext) { return _this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId); }), operators.concatMap(function (callbackContext) { return _this.userHandlerService.callbackUser(callbackContext, configId); }));
        };
        FlowsService.prototype.processImplicitFlowCallback = function (configId, hash) {
            var _this = this;
            return this.implicitFlowCallbackHandlerService.implicitFlowCallback(configId, hash).pipe(operators.concatMap(function (callbackContext) { return _this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId); }), operators.concatMap(function (callbackContext) { return _this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId); }), operators.concatMap(function (callbackContext) { return _this.userHandlerService.callbackUser(callbackContext, configId); }));
        };
        FlowsService.prototype.processRefreshToken = function (configId, customParamsRefresh) {
            var _this = this;
            return this.refreshSessionCallbackHandlerService.refreshSessionWithRefreshTokens(configId).pipe(operators.concatMap(function (callbackContext) { return _this.refreshTokenCallbackHandlerService.refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh); }), operators.concatMap(function (callbackContext) { return _this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId); }), operators.concatMap(function (callbackContext) { return _this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId); }), operators.concatMap(function (callbackContext) { return _this.userHandlerService.callbackUser(callbackContext, configId); }));
        };
        return FlowsService;
    }());
    FlowsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: FlowsService, deps: [{ token: CodeFlowCallbackHandlerService }, { token: ImplicitFlowCallbackHandlerService }, { token: HistoryJwtKeysCallbackHandlerService }, { token: UserCallbackHandlerService }, { token: StateValidationCallbackHandlerService }, { token: RefreshSessionCallbackHandlerService }, { token: RefreshTokenCallbackHandlerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FlowsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: FlowsService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: FlowsService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: CodeFlowCallbackHandlerService }, { type: ImplicitFlowCallbackHandlerService }, { type: HistoryJwtKeysCallbackHandlerService }, { type: UserCallbackHandlerService }, { type: StateValidationCallbackHandlerService }, { type: RefreshSessionCallbackHandlerService }, { type: RefreshTokenCallbackHandlerService }]; } });

    var IntervalService = /** @class */ (function () {
        function IntervalService(zone) {
            this.zone = zone;
            this.runTokenValidationRunning = null;
        }
        IntervalService.prototype.stopPeriodicTokenCheck = function () {
            if (this.runTokenValidationRunning) {
                this.runTokenValidationRunning.unsubscribe();
                this.runTokenValidationRunning = null;
            }
        };
        IntervalService.prototype.startPeriodicTokenCheck = function (repeatAfterSeconds) {
            var _this = this;
            var millisecondsDelayBetweenTokenCheck = repeatAfterSeconds * 1000;
            return new rxjs.Observable(function (subscriber) {
                var intervalId;
                _this.zone.runOutsideAngular(function () {
                    intervalId = setInterval(function () { return _this.zone.run(function () { return subscriber.next(); }); }, millisecondsDelayBetweenTokenCheck);
                });
                return function () {
                    clearInterval(intervalId);
                };
            });
        };
        return IntervalService;
    }());
    IntervalService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: IntervalService, deps: [{ token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    IntervalService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: IntervalService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: IntervalService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: i0__namespace.NgZone }]; } });

    var ImplicitFlowCallbackService = /** @class */ (function () {
        function ImplicitFlowCallbackService(flowsService, configurationProvider, router, flowsDataService, intervalService) {
            this.flowsService = flowsService;
            this.configurationProvider = configurationProvider;
            this.router = router;
            this.flowsDataService = flowsDataService;
            this.intervalService = intervalService;
        }
        ImplicitFlowCallbackService.prototype.authenticatedImplicitFlowCallback = function (configId, hash) {
            var _this = this;
            var isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);
            var _a = this.configurationProvider.getOpenIDConfiguration(configId), triggerAuthorizationResultEvent = _a.triggerAuthorizationResultEvent, postLoginRoute = _a.postLoginRoute, unauthorizedRoute = _a.unauthorizedRoute;
            return this.flowsService.processImplicitFlowCallback(configId, hash).pipe(operators.tap(function (callbackContext) {
                if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {
                    _this.router.navigateByUrl(postLoginRoute);
                }
            }), operators.catchError(function (error) {
                _this.flowsDataService.resetSilentRenewRunning(configId);
                _this.intervalService.stopPeriodicTokenCheck();
                if (!triggerAuthorizationResultEvent && !isRenewProcess) {
                    _this.router.navigateByUrl(unauthorizedRoute);
                }
                return rxjs.throwError(error);
            }));
        };
        return ImplicitFlowCallbackService;
    }());
    ImplicitFlowCallbackService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ImplicitFlowCallbackService, deps: [{ token: FlowsService }, { token: ConfigurationProvider }, { token: i2__namespace.Router }, { token: FlowsDataService }, { token: IntervalService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ImplicitFlowCallbackService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ImplicitFlowCallbackService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ImplicitFlowCallbackService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: FlowsService }, { type: ConfigurationProvider }, { type: i2__namespace.Router }, { type: FlowsDataService }, { type: IntervalService }]; } });

    var IFrameService = /** @class */ (function () {
        function IFrameService(doc, loggerService) {
            this.doc = doc;
            this.loggerService = loggerService;
        }
        IFrameService.prototype.getExistingIFrame = function (identifier) {
            var iFrameOnParent = this.getIFrameFromParentWindow(identifier);
            if (this.isIFrameElement(iFrameOnParent)) {
                return iFrameOnParent;
            }
            var iFrameOnSelf = this.getIFrameFromWindow(identifier);
            if (this.isIFrameElement(iFrameOnSelf)) {
                return iFrameOnSelf;
            }
            return null;
        };
        IFrameService.prototype.addIFrameToWindowBody = function (identifier, configId) {
            var sessionIframe = this.doc.createElement('iframe');
            sessionIframe.id = identifier;
            sessionIframe.title = identifier;
            this.loggerService.logDebug(configId, sessionIframe);
            sessionIframe.style.display = 'none';
            this.doc.body.appendChild(sessionIframe);
            return sessionIframe;
        };
        IFrameService.prototype.getIFrameFromParentWindow = function (identifier) {
            try {
                var iFrameElement = this.doc.defaultView.parent.document.getElementById(identifier);
                if (this.isIFrameElement(iFrameElement)) {
                    return iFrameElement;
                }
                return null;
            }
            catch (e) {
                return null;
            }
        };
        IFrameService.prototype.getIFrameFromWindow = function (identifier) {
            var iFrameElement = this.doc.getElementById(identifier);
            if (this.isIFrameElement(iFrameElement)) {
                return iFrameElement;
            }
            return null;
        };
        IFrameService.prototype.isIFrameElement = function (element) {
            return !!element && element instanceof HTMLIFrameElement;
        };
        return IFrameService;
    }());
    IFrameService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: IFrameService, deps: [{ token: common.DOCUMENT }, { token: LoggerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    IFrameService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: IFrameService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: IFrameService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [common.DOCUMENT]
                        }] }, { type: LoggerService }];
        } });

    var IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession';
    // http://openid.net/specs/openid-connect-session-1_0-ID4.html
    var CheckSessionService = /** @class */ (function () {
        function CheckSessionService(storagePersistenceService, loggerService, iFrameService, eventService, configurationProvider, zone) {
            this.storagePersistenceService = storagePersistenceService;
            this.loggerService = loggerService;
            this.iFrameService = iFrameService;
            this.eventService = eventService;
            this.configurationProvider = configurationProvider;
            this.zone = zone;
            this.checkSessionReceived = false;
            this.lastIFrameRefresh = 0;
            this.outstandingMessages = 0;
            this.heartBeatInterval = 3000;
            this.iframeRefreshInterval = 60000;
            this.checkSessionChangedInternal$ = new rxjs.BehaviorSubject(false);
        }
        Object.defineProperty(CheckSessionService.prototype, "checkSessionChanged$", {
            get: function () {
                return this.checkSessionChangedInternal$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        CheckSessionService.prototype.isCheckSessionConfigured = function (configId) {
            var startCheckSession = this.configurationProvider.getOpenIDConfiguration(configId).startCheckSession;
            return startCheckSession;
        };
        CheckSessionService.prototype.start = function (configId) {
            if (!!this.scheduledHeartBeatRunning) {
                return;
            }
            var clientId = this.configurationProvider.getOpenIDConfiguration(configId).clientId;
            this.pollServerSession(clientId, configId);
        };
        CheckSessionService.prototype.stop = function () {
            if (!this.scheduledHeartBeatRunning) {
                return;
            }
            this.clearScheduledHeartBeat();
            this.checkSessionReceived = false;
        };
        CheckSessionService.prototype.serverStateChanged = function (configId) {
            var startCheckSession = this.configurationProvider.getOpenIDConfiguration(configId).startCheckSession;
            return startCheckSession && this.checkSessionReceived;
        };
        CheckSessionService.prototype.getExistingIframe = function () {
            return this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);
        };
        CheckSessionService.prototype.init = function (configId) {
            var _this = this;
            if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {
                return rxjs.of(undefined);
            }
            var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            if (!authWellKnownEndPoints) {
                this.loggerService.logWarning(configId, 'CheckSession - init check session: authWellKnownEndpoints is undefined. Returning.');
                return rxjs.of();
            }
            var existingIframe = this.getOrCreateIframe(configId);
            var checkSessionIframe = authWellKnownEndPoints.checkSessionIframe;
            if (checkSessionIframe) {
                existingIframe.contentWindow.location.replace(checkSessionIframe);
            }
            else {
                this.loggerService.logWarning(configId, 'CheckSession - init check session: checkSessionIframe is not configured to run');
            }
            return new rxjs.Observable(function (observer) {
                existingIframe.onload = function () {
                    _this.lastIFrameRefresh = Date.now();
                    observer.next();
                    observer.complete();
                };
            });
        };
        CheckSessionService.prototype.pollServerSession = function (clientId, configId) {
            var _this = this;
            this.outstandingMessages = 0;
            var pollServerSessionRecur = function () {
                _this.init(configId)
                    .pipe(operators.take(1))
                    .subscribe(function () {
                    var _a;
                    var existingIframe = _this.getExistingIframe();
                    if (existingIframe && clientId) {
                        _this.loggerService.logDebug(configId, "CheckSession - clientId : '" + clientId + "' - existingIframe: '" + existingIframe + "'");
                        var sessionState = _this.storagePersistenceService.read('session_state', configId);
                        var authWellKnownEndPoints = _this.storagePersistenceService.read('authWellKnownEndPoints', configId);
                        if (sessionState && (authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe)) {
                            var iframeOrigin = (_a = new URL(authWellKnownEndPoints.checkSessionIframe)) === null || _a === void 0 ? void 0 : _a.origin;
                            _this.outstandingMessages++;
                            existingIframe.contentWindow.postMessage(clientId + ' ' + sessionState, iframeOrigin);
                        }
                        else {
                            _this.loggerService.logDebug(configId, "CheckSession - session_state is '" + sessionState + "' - AuthWellKnownEndPoints is '" + JSON.stringify(authWellKnownEndPoints, null, 2) + "'");
                            _this.checkSessionChangedInternal$.next(true);
                        }
                    }
                    else {
                        _this.loggerService.logWarning(configId, "CheckSession - OidcSecurityCheckSession pollServerSession checkSession IFrame does not exist:\n               clientId : '" + clientId + "' - existingIframe: '" + existingIframe + "'");
                    }
                    // after sending three messages with no response, fail.
                    if (_this.outstandingMessages > 3) {
                        _this.loggerService.logError(configId, "CheckSession - OidcSecurityCheckSession not receiving check session response messages.\n                            Outstanding messages: '" + _this.outstandingMessages + "'. Server unreachable?");
                    }
                    _this.zone.runOutsideAngular(function () {
                        _this.scheduledHeartBeatRunning = setTimeout(function () { return _this.zone.run(pollServerSessionRecur); }, _this.heartBeatInterval);
                    });
                });
            };
            pollServerSessionRecur();
        };
        CheckSessionService.prototype.clearScheduledHeartBeat = function () {
            clearTimeout(this.scheduledHeartBeatRunning);
            this.scheduledHeartBeatRunning = null;
        };
        CheckSessionService.prototype.messageHandler = function (configId, e) {
            var _a;
            var existingIFrame = this.getExistingIframe();
            var authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            var startsWith = !!((_a = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe) === null || _a === void 0 ? void 0 : _a.startsWith(e.origin));
            this.outstandingMessages = 0;
            if (existingIFrame && startsWith && e.source === existingIFrame.contentWindow) {
                if (e.data === 'error') {
                    this.loggerService.logWarning(configId, 'CheckSession - error from check session messageHandler');
                }
                else if (e.data === 'changed') {
                    this.loggerService.logDebug(configId, "CheckSession - " + e + " from check session messageHandler");
                    this.checkSessionReceived = true;
                    this.eventService.fireEvent(exports.EventTypes.CheckSessionReceived, e.data);
                    this.checkSessionChangedInternal$.next(true);
                }
                else {
                    this.eventService.fireEvent(exports.EventTypes.CheckSessionReceived, e.data);
                    this.loggerService.logDebug(configId, "CheckSession - " + e.data + " from check session messageHandler");
                }
            }
        };
        CheckSessionService.prototype.bindMessageEventToIframe = function (configId) {
            var iframeMessageEvent = this.messageHandler.bind(this, configId);
            window.addEventListener('message', iframeMessageEvent, false);
        };
        CheckSessionService.prototype.getOrCreateIframe = function (configId) {
            var existingIframe = this.getExistingIframe();
            if (!existingIframe) {
                var frame = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER, configId);
                this.bindMessageEventToIframe(configId);
                return frame;
            }
            return existingIframe;
        };
        return CheckSessionService;
    }());
    CheckSessionService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CheckSessionService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: IFrameService }, { token: PublicEventsService }, { token: ConfigurationProvider }, { token: i0__namespace.NgZone }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CheckSessionService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CheckSessionService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CheckSessionService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: IFrameService }, { type: PublicEventsService }, { type: ConfigurationProvider }, { type: i0__namespace.NgZone }]; } });

    var CurrentUrlService = /** @class */ (function () {
        function CurrentUrlService(doc) {
            this.doc = doc;
        }
        CurrentUrlService.prototype.getStateParamFromCurrentUrl = function () {
            var currentUrl = this.getCurrentUrl();
            var parsedUrl = new URL(currentUrl);
            var urlParams = new URLSearchParams(parsedUrl.search);
            var stateFromUrl = urlParams.get('state');
            return stateFromUrl;
        };
        CurrentUrlService.prototype.currentUrlHasStateParam = function () {
            return !!this.getStateParamFromCurrentUrl();
        };
        CurrentUrlService.prototype.getCurrentUrl = function () {
            return this.doc.defaultView.location.toString();
        };
        return CurrentUrlService;
    }());
    CurrentUrlService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CurrentUrlService, deps: [{ token: common.DOCUMENT }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CurrentUrlService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CurrentUrlService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CurrentUrlService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [common.DOCUMENT]
                        }] }];
        } });

    var IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';
    var SilentRenewService = /** @class */ (function () {
        function SilentRenewService(configurationProvider, iFrameService, flowsService, resetAuthDataService, flowsDataService, authStateService, loggerService, flowHelper, implicitFlowCallbackService, intervalService) {
            this.configurationProvider = configurationProvider;
            this.iFrameService = iFrameService;
            this.flowsService = flowsService;
            this.resetAuthDataService = resetAuthDataService;
            this.flowsDataService = flowsDataService;
            this.authStateService = authStateService;
            this.loggerService = loggerService;
            this.flowHelper = flowHelper;
            this.implicitFlowCallbackService = implicitFlowCallbackService;
            this.intervalService = intervalService;
            this.refreshSessionWithIFrameCompletedInternal$ = new rxjs.Subject();
        }
        Object.defineProperty(SilentRenewService.prototype, "refreshSessionWithIFrameCompleted$", {
            get: function () {
                return this.refreshSessionWithIFrameCompletedInternal$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        SilentRenewService.prototype.getOrCreateIframe = function (configId) {
            var existingIframe = this.getExistingIframe();
            if (!existingIframe) {
                return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER, configId);
            }
            return existingIframe;
        };
        SilentRenewService.prototype.isSilentRenewConfigured = function (configId) {
            var _a = this.configurationProvider.getOpenIDConfiguration(configId), useRefreshToken = _a.useRefreshToken, silentRenew = _a.silentRenew;
            return !useRefreshToken && silentRenew;
        };
        SilentRenewService.prototype.codeFlowCallbackSilentRenewIframe = function (urlParts, configId) {
            var _this = this;
            var params = new i1.HttpParams({
                fromString: urlParts[1],
            });
            var error = params.get('error');
            if (error) {
                this.authStateService.updateAndPublishAuthState({
                    isAuthenticated: false,
                    validationResult: exports.ValidationResult.LoginRequired,
                    isRenewProcess: true,
                });
                this.resetAuthDataService.resetAuthorizationData(configId);
                this.flowsDataService.setNonce('', configId);
                this.intervalService.stopPeriodicTokenCheck();
                return rxjs.throwError(error);
            }
            var code = params.get('code');
            var state = params.get('state');
            var sessionState = params.get('session_state');
            var callbackContext = {
                code: code,
                refreshToken: null,
                state: state,
                sessionState: sessionState,
                authResult: null,
                isRenewProcess: true,
                jwtKeys: null,
                validationResult: null,
                existingIdToken: null,
            };
            return this.flowsService.processSilentRenewCodeFlowCallback(callbackContext, configId).pipe(operators.catchError(function (errorFromFlow) {
                _this.intervalService.stopPeriodicTokenCheck();
                _this.resetAuthDataService.resetAuthorizationData(configId);
                return rxjs.throwError(errorFromFlow);
            }));
        };
        SilentRenewService.prototype.silentRenewEventHandler = function (e, configId) {
            var _this = this;
            this.loggerService.logDebug(configId, 'silentRenewEventHandler');
            if (!e.detail) {
                return;
            }
            var callback$ = rxjs.of(null);
            var isCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);
            if (isCodeFlow) {
                var urlParts = e.detail.toString().split('?');
                callback$ = this.codeFlowCallbackSilentRenewIframe(urlParts, configId);
            }
            else {
                callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId, e.detail);
            }
            callback$.subscribe(function (callbackContext) {
                _this.refreshSessionWithIFrameCompletedInternal$.next(callbackContext);
                _this.flowsDataService.resetSilentRenewRunning(configId);
            }, function (err) {
                _this.loggerService.logError(configId, 'Error: ' + err);
                _this.refreshSessionWithIFrameCompletedInternal$.next(null);
                _this.flowsDataService.resetSilentRenewRunning(configId);
            });
        };
        SilentRenewService.prototype.getExistingIframe = function () {
            return this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);
        };
        return SilentRenewService;
    }());
    SilentRenewService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: SilentRenewService, deps: [{ token: ConfigurationProvider }, { token: IFrameService }, { token: FlowsService }, { token: ResetAuthDataService }, { token: FlowsDataService }, { token: AuthStateService }, { token: LoggerService }, { token: FlowHelper }, { token: ImplicitFlowCallbackService }, { token: IntervalService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SilentRenewService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: SilentRenewService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: SilentRenewService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: IFrameService }, { type: FlowsService }, { type: ResetAuthDataService }, { type: FlowsDataService }, { type: AuthStateService }, { type: LoggerService }, { type: FlowHelper }, { type: ImplicitFlowCallbackService }, { type: IntervalService }]; } });

    var CodeFlowCallbackService = /** @class */ (function () {
        function CodeFlowCallbackService(flowsService, flowsDataService, intervalService, configurationProvider, router) {
            this.flowsService = flowsService;
            this.flowsDataService = flowsDataService;
            this.intervalService = intervalService;
            this.configurationProvider = configurationProvider;
            this.router = router;
        }
        CodeFlowCallbackService.prototype.authenticatedCallbackWithCode = function (urlToCheck, configId) {
            var _this = this;
            var isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);
            var _a = this.configurationProvider.getOpenIDConfiguration(configId), triggerAuthorizationResultEvent = _a.triggerAuthorizationResultEvent, postLoginRoute = _a.postLoginRoute, unauthorizedRoute = _a.unauthorizedRoute;
            return this.flowsService.processCodeFlowCallback(urlToCheck, configId).pipe(operators.tap(function (callbackContext) {
                if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {
                    _this.router.navigateByUrl(postLoginRoute);
                }
            }), operators.catchError(function (error) {
                _this.flowsDataService.resetSilentRenewRunning(configId);
                _this.intervalService.stopPeriodicTokenCheck();
                if (!triggerAuthorizationResultEvent && !isRenewProcess) {
                    _this.router.navigateByUrl(unauthorizedRoute);
                }
                return rxjs.throwError(error);
            }));
        };
        return CodeFlowCallbackService;
    }());
    CodeFlowCallbackService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CodeFlowCallbackService, deps: [{ token: FlowsService }, { token: FlowsDataService }, { token: IntervalService }, { token: ConfigurationProvider }, { token: i2__namespace.Router }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CodeFlowCallbackService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CodeFlowCallbackService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CodeFlowCallbackService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: FlowsService }, { type: FlowsDataService }, { type: IntervalService }, { type: ConfigurationProvider }, { type: i2__namespace.Router }]; } });

    var CallbackService = /** @class */ (function () {
        function CallbackService(urlService, flowHelper, implicitFlowCallbackService, codeFlowCallbackService) {
            this.urlService = urlService;
            this.flowHelper = flowHelper;
            this.implicitFlowCallbackService = implicitFlowCallbackService;
            this.codeFlowCallbackService = codeFlowCallbackService;
            this.stsCallbackInternal$ = new rxjs.Subject();
        }
        Object.defineProperty(CallbackService.prototype, "stsCallback$", {
            get: function () {
                return this.stsCallbackInternal$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        CallbackService.prototype.isCallback = function (currentUrl) {
            return this.urlService.isCallbackFromSts(currentUrl);
        };
        CallbackService.prototype.handleCallbackAndFireEvents = function (currentCallbackUrl, configId) {
            var _this = this;
            var callback$;
            if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {
                callback$ = this.codeFlowCallbackService.authenticatedCallbackWithCode(currentCallbackUrl, configId);
            }
            else if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {
                callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId);
            }
            return callback$.pipe(operators.tap(function () { return _this.stsCallbackInternal$.next(); }));
        };
        return CallbackService;
    }());
    CallbackService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CallbackService, deps: [{ token: UrlService }, { token: FlowHelper }, { token: ImplicitFlowCallbackService }, { token: CodeFlowCallbackService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CallbackService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CallbackService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CallbackService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: UrlService }, { type: FlowHelper }, { type: ImplicitFlowCallbackService }, { type: CodeFlowCallbackService }]; } });

    var WELL_KNOWN_SUFFIX = "/.well-known/openid-configuration";
    var AuthWellKnownDataService = /** @class */ (function () {
        function AuthWellKnownDataService(http) {
            this.http = http;
        }
        AuthWellKnownDataService.prototype.getWellKnownEndPointsFromUrl = function (authWellknownEndpoint, configId) {
            return this.getWellKnownDocument(authWellknownEndpoint, configId).pipe(operators.map(function (wellKnownEndpoints) { return ({
                issuer: wellKnownEndpoints.issuer,
                jwksUri: wellKnownEndpoints.jwks_uri,
                authorizationEndpoint: wellKnownEndpoints.authorization_endpoint,
                tokenEndpoint: wellKnownEndpoints.token_endpoint,
                userInfoEndpoint: wellKnownEndpoints.userinfo_endpoint,
                endSessionEndpoint: wellKnownEndpoints.end_session_endpoint,
                checkSessionIframe: wellKnownEndpoints.check_session_iframe,
                revocationEndpoint: wellKnownEndpoints.revocation_endpoint,
                introspectionEndpoint: wellKnownEndpoints.introspection_endpoint,
                parEndpoint: wellKnownEndpoints.pushed_authorization_request_endpoint,
            }); }));
        };
        AuthWellKnownDataService.prototype.getWellKnownDocument = function (wellKnownEndpoint, configId) {
            var url = wellKnownEndpoint;
            if (!wellKnownEndpoint.includes(WELL_KNOWN_SUFFIX)) {
                url = "" + wellKnownEndpoint + WELL_KNOWN_SUFFIX;
            }
            return this.http.get(url, configId).pipe(operators.retry(2));
        };
        return AuthWellKnownDataService;
    }());
    AuthWellKnownDataService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthWellKnownDataService, deps: [{ token: DataService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthWellKnownDataService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthWellKnownDataService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthWellKnownDataService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: DataService }]; } });

    var AuthWellKnownService = /** @class */ (function () {
        function AuthWellKnownService(publicEventsService, dataService, storagePersistenceService) {
            this.publicEventsService = publicEventsService;
            this.dataService = dataService;
            this.storagePersistenceService = storagePersistenceService;
        }
        AuthWellKnownService.prototype.getAuthWellKnownEndPoints = function (authWellknownEndpointUrl, configId) {
            var _this = this;
            var alreadySavedWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            if (!!alreadySavedWellKnownEndpoints) {
                return rxjs.of(alreadySavedWellKnownEndpoints);
            }
            return this.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId).pipe(operators.tap(function (mappedWellKnownEndpoints) { return _this.storeWellKnownEndpoints(configId, mappedWellKnownEndpoints); }), operators.catchError(function (error) {
                _this.publicEventsService.fireEvent(exports.EventTypes.ConfigLoadingFailed, null);
                return rxjs.throwError(error);
            }));
        };
        AuthWellKnownService.prototype.storeWellKnownEndpoints = function (configId, mappedWellKnownEndpoints) {
            this.storagePersistenceService.write('authWellKnownEndPoints', mappedWellKnownEndpoints, configId);
        };
        AuthWellKnownService.prototype.getWellKnownEndPointsFromUrl = function (authWellknownEndpointUrl, configId) {
            return this.dataService.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId);
        };
        return AuthWellKnownService;
    }());
    AuthWellKnownService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthWellKnownService, deps: [{ token: PublicEventsService }, { token: AuthWellKnownDataService }, { token: StoragePersistenceService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthWellKnownService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthWellKnownService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthWellKnownService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: PublicEventsService }, { type: AuthWellKnownDataService }, { type: StoragePersistenceService }]; } });

    var RefreshSessionIframeService = /** @class */ (function () {
        function RefreshSessionIframeService(doc, loggerService, urlService, silentRenewService, rendererFactory) {
            this.doc = doc;
            this.loggerService = loggerService;
            this.urlService = urlService;
            this.silentRenewService = silentRenewService;
            this.renderer = rendererFactory.createRenderer(null, null);
        }
        RefreshSessionIframeService.prototype.refreshSessionWithIframe = function (configId, customParams) {
            this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize Iframe renew');
            var url = this.urlService.getRefreshSessionSilentRenewUrl(configId, customParams);
            return this.sendAuthorizeRequestUsingSilentRenew(url, configId);
        };
        RefreshSessionIframeService.prototype.sendAuthorizeRequestUsingSilentRenew = function (url, configId) {
            var _this = this;
            var sessionIframe = this.silentRenewService.getOrCreateIframe(configId);
            this.initSilentRenewRequest(configId);
            this.loggerService.logDebug(configId, 'sendAuthorizeRequestUsingSilentRenew for URL:' + url);
            return new rxjs.Observable(function (observer) {
                var onLoadHandler = function () {
                    sessionIframe.removeEventListener('load', onLoadHandler);
                    _this.loggerService.logDebug(configId, 'removed event listener from IFrame');
                    observer.next(true);
                    observer.complete();
                };
                sessionIframe.addEventListener('load', onLoadHandler);
                sessionIframe.contentWindow.location.replace(url);
            });
        };
        RefreshSessionIframeService.prototype.initSilentRenewRequest = function (configId) {
            var _this = this;
            var instanceId = Math.random();
            var initDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-init', function (e) {
                if (e.detail !== instanceId) {
                    initDestroyHandler();
                    renewDestroyHandler();
                }
            });
            var renewDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-message', function (e) { return _this.silentRenewService.silentRenewEventHandler(e, configId); });
            this.doc.defaultView.dispatchEvent(new CustomEvent('oidc-silent-renew-init', {
                detail: instanceId,
            }));
        };
        return RefreshSessionIframeService;
    }());
    RefreshSessionIframeService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshSessionIframeService, deps: [{ token: common.DOCUMENT }, { token: LoggerService }, { token: UrlService }, { token: SilentRenewService }, { token: i0__namespace.RendererFactory2 }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RefreshSessionIframeService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshSessionIframeService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshSessionIframeService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [common.DOCUMENT]
                        }] }, { type: LoggerService }, { type: UrlService }, { type: SilentRenewService }, { type: i0__namespace.RendererFactory2 }];
        } });

    var RefreshSessionRefreshTokenService = /** @class */ (function () {
        function RefreshSessionRefreshTokenService(loggerService, resetAuthDataService, flowsService, intervalService) {
            this.loggerService = loggerService;
            this.resetAuthDataService = resetAuthDataService;
            this.flowsService = flowsService;
            this.intervalService = intervalService;
        }
        RefreshSessionRefreshTokenService.prototype.refreshSessionWithRefreshTokens = function (configId, customParamsRefresh) {
            var _this = this;
            this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize');
            return this.flowsService.processRefreshToken(configId, customParamsRefresh).pipe(operators.catchError(function (error) {
                _this.intervalService.stopPeriodicTokenCheck();
                _this.resetAuthDataService.resetAuthorizationData(configId);
                return rxjs.throwError(error);
            }));
        };
        return RefreshSessionRefreshTokenService;
    }());
    RefreshSessionRefreshTokenService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshSessionRefreshTokenService, deps: [{ token: LoggerService }, { token: ResetAuthDataService }, { token: FlowsService }, { token: IntervalService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RefreshSessionRefreshTokenService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshSessionRefreshTokenService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshSessionRefreshTokenService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResetAuthDataService }, { type: FlowsService }, { type: IntervalService }]; } });

    var MAX_RETRY_ATTEMPTS = 3;
    var RefreshSessionService = /** @class */ (function () {
        function RefreshSessionService(flowHelper, configurationProvider, flowsDataService, loggerService, silentRenewService, authStateService, authWellKnownService, refreshSessionIframeService, storagePersistenceService, refreshSessionRefreshTokenService, userService) {
            this.flowHelper = flowHelper;
            this.configurationProvider = configurationProvider;
            this.flowsDataService = flowsDataService;
            this.loggerService = loggerService;
            this.silentRenewService = silentRenewService;
            this.authStateService = authStateService;
            this.authWellKnownService = authWellKnownService;
            this.refreshSessionIframeService = refreshSessionIframeService;
            this.storagePersistenceService = storagePersistenceService;
            this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;
            this.userService = userService;
        }
        RefreshSessionService.prototype.userForceRefreshSession = function (configId, extraCustomParams) {
            this.persistCustomParams(extraCustomParams, configId);
            return this.forceRefreshSession(configId, extraCustomParams);
        };
        RefreshSessionService.prototype.forceRefreshSession = function (configId, extraCustomParams) {
            var _this = this;
            var customParamsRefreshTokenRequest = this.configurationProvider.getOpenIDConfiguration().customParamsRefreshTokenRequest;
            var mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), extraCustomParams);
            if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {
                return this.startRefreshSession(configId, mergedParams).pipe(operators.map(function () {
                    var isAuthenticated = _this.authStateService.areAuthStorageTokensValid(configId);
                    if (isAuthenticated) {
                        return {
                            idToken: _this.authStateService.getIdToken(configId),
                            accessToken: _this.authStateService.getAccessToken(configId),
                            userData: _this.userService.getUserDataFromStore(configId),
                            isAuthenticated: isAuthenticated,
                            configId: configId,
                        };
                    }
                    return null;
                }));
            }
            var silentRenewTimeoutInSeconds = this.configurationProvider.getOpenIDConfiguration(configId).silentRenewTimeoutInSeconds;
            var timeOutTime = silentRenewTimeoutInSeconds * 1000;
            return rxjs.forkJoin([
                this.startRefreshSession(configId, extraCustomParams),
                this.silentRenewService.refreshSessionWithIFrameCompleted$.pipe(operators.take(1)),
            ]).pipe(operators.timeout(timeOutTime), operators.retryWhen(this.timeoutRetryStrategy.bind(this)), operators.map(function (_c) {
                var _d = __read(_c, 2), _ = _d[0], callbackContext = _d[1];
                var _a, _b;
                var isAuthenticated = _this.authStateService.areAuthStorageTokensValid(configId);
                if (isAuthenticated) {
                    return {
                        idToken: (_a = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _a === void 0 ? void 0 : _a.id_token,
                        accessToken: (_b = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _b === void 0 ? void 0 : _b.access_token,
                        userData: _this.userService.getUserDataFromStore(configId),
                        isAuthenticated: isAuthenticated,
                        configId: configId,
                    };
                }
                return null;
            }));
        };
        RefreshSessionService.prototype.persistCustomParams = function (extraCustomParams, configId) {
            var useRefreshToken = this.configurationProvider.getOpenIDConfiguration().useRefreshToken;
            if (extraCustomParams) {
                if (useRefreshToken) {
                    this.storagePersistenceService.write('storageCustomParamsRefresh', extraCustomParams, configId);
                }
                else {
                    this.storagePersistenceService.write('storageCustomParamsAuthRequest', extraCustomParams, configId);
                }
            }
        };
        RefreshSessionService.prototype.startRefreshSession = function (configId, extraCustomParams) {
            var _this = this;
            var isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);
            this.loggerService.logDebug(configId, "Checking: silentRenewRunning: " + isSilentRenewRunning);
            var shouldBeExecuted = !isSilentRenewRunning;
            if (!shouldBeExecuted) {
                return rxjs.of(null);
            }
            var authWellknownEndpointUrl = (this.configurationProvider.getOpenIDConfiguration(configId) || {}).authWellknownEndpointUrl;
            if (!authWellknownEndpointUrl) {
                this.loggerService.logError(configId, 'no authWellKnownEndpoint given!');
                return rxjs.of(null);
            }
            return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(operators.switchMap(function () {
                _this.flowsDataService.setSilentRenewRunning(configId);
                if (_this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {
                    // Refresh Session using Refresh tokens
                    return _this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, extraCustomParams);
                }
                return _this.refreshSessionIframeService.refreshSessionWithIframe(configId, extraCustomParams);
            }));
        };
        RefreshSessionService.prototype.timeoutRetryStrategy = function (errorAttempts, configId) {
            var _this = this;
            return errorAttempts.pipe(operators.mergeMap(function (error, index) {
                var scalingDuration = 1000;
                var currentAttempt = index + 1;
                if (!(error instanceof rxjs.TimeoutError) || currentAttempt > MAX_RETRY_ATTEMPTS) {
                    return rxjs.throwError(error);
                }
                _this.loggerService.logDebug(configId, "forceRefreshSession timeout. Attempt #" + currentAttempt);
                _this.flowsDataService.resetSilentRenewRunning(configId);
                return rxjs.timer(currentAttempt * scalingDuration);
            }));
        };
        return RefreshSessionService;
    }());
    RefreshSessionService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshSessionService, deps: [{ token: FlowHelper }, { token: ConfigurationProvider }, { token: FlowsDataService }, { token: LoggerService }, { token: SilentRenewService }, { token: AuthStateService }, { token: AuthWellKnownService }, { token: RefreshSessionIframeService }, { token: StoragePersistenceService }, { token: RefreshSessionRefreshTokenService }, { token: UserService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RefreshSessionService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshSessionService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RefreshSessionService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: FlowHelper }, { type: ConfigurationProvider }, { type: FlowsDataService }, { type: LoggerService }, { type: SilentRenewService }, { type: AuthStateService }, { type: AuthWellKnownService }, { type: RefreshSessionIframeService }, { type: StoragePersistenceService }, { type: RefreshSessionRefreshTokenService }, { type: UserService }]; } });

    var PeriodicallyTokenCheckService = /** @class */ (function () {
        function PeriodicallyTokenCheckService(resetAuthDataService, flowHelper, configurationProvider, flowsDataService, loggerService, userService, authStateService, refreshSessionIframeService, refreshSessionRefreshTokenService, intervalService, storagePersistenceService, publicEventsService) {
            this.resetAuthDataService = resetAuthDataService;
            this.flowHelper = flowHelper;
            this.configurationProvider = configurationProvider;
            this.flowsDataService = flowsDataService;
            this.loggerService = loggerService;
            this.userService = userService;
            this.authStateService = authStateService;
            this.refreshSessionIframeService = refreshSessionIframeService;
            this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;
            this.intervalService = intervalService;
            this.storagePersistenceService = storagePersistenceService;
            this.publicEventsService = publicEventsService;
        }
        PeriodicallyTokenCheckService.prototype.startTokenValidationPeriodically = function () {
            var _this = this;
            var configsWithSilentRenewEnabled = this.getConfigsWithSilentRenewEnabled();
            if (configsWithSilentRenewEnabled.length <= 0) {
                return;
            }
            var refreshTimeInSeconds = this.getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled);
            if (!!this.intervalService.runTokenValidationRunning) {
                return;
            }
            // START PERIODICALLY CHECK ONCE AND CHECK EACH CONFIG WHICH HAS IT ENABLED
            var periodicallyCheck$ = this.intervalService.startPeriodicTokenCheck(refreshTimeInSeconds).pipe(operators.switchMap(function () {
                var objectWithConfigIdsAndRefreshEvent = {};
                configsWithSilentRenewEnabled.forEach(function (_a) {
                    var configId = _a.configId;
                    objectWithConfigIdsAndRefreshEvent[configId] = _this.getRefreshEvent(configId);
                });
                return rxjs.forkJoin(objectWithConfigIdsAndRefreshEvent);
            }));
            this.intervalService.runTokenValidationRunning = periodicallyCheck$.subscribe(function (objectWithConfigIds) {
                var e_1, _a;
                try {
                    for (var _b = __values(Object.entries(objectWithConfigIds)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var _d = __read(_c.value, 2), key = _d[0], _ = _d[1];
                        _this.loggerService.logDebug(key, 'silent renew, periodic check finished!');
                        if (_this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(key)) {
                            _this.flowsDataService.resetSilentRenewRunning(key);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            });
        };
        PeriodicallyTokenCheckService.prototype.getRefreshEvent = function (configId) {
            var _this = this;
            var shouldStartRefreshEvent = this.shouldStartPeriodicallyCheckForConfig(configId);
            if (!shouldStartRefreshEvent) {
                return rxjs.of(null);
            }
            var refreshEvent$ = this.createRefreshEventForConfig(configId);
            this.publicEventsService.fireEvent(exports.EventTypes.SilentRenewStarted);
            var refreshEventWithErrorHandler$ = refreshEvent$.pipe(operators.catchError(function (error) {
                _this.loggerService.logError(configId, 'silent renew failed!', error);
                _this.flowsDataService.resetSilentRenewRunning(configId);
                return rxjs.throwError(error);
            }));
            return refreshEventWithErrorHandler$;
        };
        PeriodicallyTokenCheckService.prototype.getSmallestRefreshTimeFromConfigs = function (configsWithSilentRenewEnabled) {
            var result = configsWithSilentRenewEnabled.reduce(function (prev, curr) { return prev.tokenRefreshInSeconds < curr.tokenRefreshInSeconds ? prev : curr; });
            return result.tokenRefreshInSeconds;
        };
        PeriodicallyTokenCheckService.prototype.getConfigsWithSilentRenewEnabled = function () {
            return this.configurationProvider.getAllConfigurations().filter(function (x) { return x.silentRenew; });
        };
        PeriodicallyTokenCheckService.prototype.createRefreshEventForConfig = function (configId) {
            this.loggerService.logDebug(configId, 'starting silent renew...');
            var config = this.configurationProvider.getOpenIDConfiguration(configId);
            if (!(config === null || config === void 0 ? void 0 : config.silentRenew)) {
                this.resetAuthDataService.resetAuthorizationData(configId);
                return rxjs.of(null);
            }
            this.flowsDataService.setSilentRenewRunning(configId);
            if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {
                // Retrieve Dynamically Set Custom Params for refresh body
                var customParamsRefresh = this.storagePersistenceService.read('storageCustomParamsRefresh', configId) || {};
                var customParamsRefreshTokenRequest = this.configurationProvider.getOpenIDConfiguration(configId).customParamsRefreshTokenRequest;
                var mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), customParamsRefresh);
                // Refresh Session using Refresh tokens
                return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, mergedParams);
            }
            // Retrieve Dynamically Set Custom Params
            var customParams = this.storagePersistenceService.read('storageCustomParamsAuthRequest', configId);
            return this.refreshSessionIframeService.refreshSessionWithIframe(configId, customParams);
        };
        PeriodicallyTokenCheckService.prototype.shouldStartPeriodicallyCheckForConfig = function (configId) {
            var idToken = this.authStateService.getIdToken(configId);
            var isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);
            var userDataFromStore = this.userService.getUserDataFromStore(configId);
            this.loggerService.logDebug(configId, "Checking: silentRenewRunning: " + isSilentRenewRunning + " - has idToken: " + !!idToken + " - has userData: " + !!userDataFromStore);
            var shouldBeExecuted = !!userDataFromStore && !isSilentRenewRunning && !!idToken;
            if (!shouldBeExecuted) {
                return false;
            }
            var idTokenStillValid = this.authStateService.hasIdTokenExpiredAndRenewCheckIsEnabled(configId);
            var accessTokenHasExpired = this.authStateService.hasAccessTokenExpiredIfExpiryExists(configId);
            if (!idTokenStillValid && !accessTokenHasExpired) {
                return false;
            }
            return true;
        };
        return PeriodicallyTokenCheckService;
    }());
    PeriodicallyTokenCheckService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PeriodicallyTokenCheckService, deps: [{ token: ResetAuthDataService }, { token: FlowHelper }, { token: ConfigurationProvider }, { token: FlowsDataService }, { token: LoggerService }, { token: UserService }, { token: AuthStateService }, { token: RefreshSessionIframeService }, { token: RefreshSessionRefreshTokenService }, { token: IntervalService }, { token: StoragePersistenceService }, { token: PublicEventsService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PeriodicallyTokenCheckService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PeriodicallyTokenCheckService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PeriodicallyTokenCheckService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ResetAuthDataService }, { type: FlowHelper }, { type: ConfigurationProvider }, { type: FlowsDataService }, { type: LoggerService }, { type: UserService }, { type: AuthStateService }, { type: RefreshSessionIframeService }, { type: RefreshSessionRefreshTokenService }, { type: IntervalService }, { type: StoragePersistenceService }, { type: PublicEventsService }]; } });

    var PopUpService = /** @class */ (function () {
        function PopUpService() {
            this.STORAGE_IDENTIFIER = 'popupauth';
            this.resultInternal$ = new rxjs.Subject();
        }
        Object.defineProperty(PopUpService.prototype, "result$", {
            get: function () {
                return this.resultInternal$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        PopUpService.prototype.isCurrentlyInPopup = function () {
            if (this.canAccessSessionStorage()) {
                var popup = sessionStorage.getItem(this.STORAGE_IDENTIFIER);
                return !!window.opener && window.opener !== window && !!popup;
            }
            return false;
        };
        PopUpService.prototype.openPopUp = function (url, popupOptions) {
            var _this = this;
            var optionsToPass = this.getOptions(popupOptions);
            this.popUp = window.open(url, '_blank', optionsToPass);
            this.popUp.sessionStorage.setItem(this.STORAGE_IDENTIFIER, 'true');
            var listener = function (event) {
                if (!(event === null || event === void 0 ? void 0 : event.data) || typeof event.data !== 'string') {
                    return;
                }
                _this.resultInternal$.next({ userClosed: false, receivedUrl: event.data });
                _this.cleanUp(listener);
            };
            window.addEventListener('message', listener, false);
            this.handle = window.setInterval(function () {
                if (_this.popUp.closed) {
                    _this.resultInternal$.next({ userClosed: true });
                    _this.cleanUp(listener);
                }
            }, 200);
        };
        PopUpService.prototype.sendMessageToMainWindow = function (url) {
            if (window.opener) {
                this.sendMessage(url, window.location.href);
            }
        };
        PopUpService.prototype.cleanUp = function (listener) {
            var _a;
            window.removeEventListener('message', listener, false);
            window.clearInterval(this.handle);
            if (this.popUp) {
                (_a = this.popUp.sessionStorage) === null || _a === void 0 ? void 0 : _a.removeItem(this.STORAGE_IDENTIFIER);
                this.popUp.close();
                this.popUp = null;
            }
        };
        PopUpService.prototype.sendMessage = function (url, href) {
            window.opener.postMessage(url, href);
        };
        PopUpService.prototype.getOptions = function (popupOptions) {
            var popupDefaultOptions = { width: 500, height: 500, left: 50, top: 50 };
            var options = Object.assign(Object.assign({}, popupDefaultOptions), (popupOptions || {}));
            var left = window.screenLeft + (window.outerWidth - options.width) / 2;
            var top = window.screenTop + (window.outerHeight - options.height) / 2;
            options.left = left;
            options.top = top;
            return Object.entries(options)
                .map(function (_b) {
                var _c = __read(_b, 2), key = _c[0], value = _c[1];
                return encodeURIComponent(key) + "=" + encodeURIComponent(value);
            })
                .join(',');
        };
        PopUpService.prototype.canAccessSessionStorage = function () {
            return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';
        };
        return PopUpService;
    }());
    PopUpService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PopUpService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PopUpService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PopUpService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PopUpService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }] });

    var CheckAuthService = /** @class */ (function () {
        function CheckAuthService(checkSessionService, currentUrlService, silentRenewService, userService, loggerService, configurationProvider, authStateService, callbackService, refreshSessionService, periodicallyTokenCheckService, popupService, autoLoginService, storagePersistenceService) {
            this.checkSessionService = checkSessionService;
            this.currentUrlService = currentUrlService;
            this.silentRenewService = silentRenewService;
            this.userService = userService;
            this.loggerService = loggerService;
            this.configurationProvider = configurationProvider;
            this.authStateService = authStateService;
            this.callbackService = callbackService;
            this.refreshSessionService = refreshSessionService;
            this.periodicallyTokenCheckService = periodicallyTokenCheckService;
            this.popupService = popupService;
            this.autoLoginService = autoLoginService;
            this.storagePersistenceService = storagePersistenceService;
        }
        CheckAuthService.prototype.checkAuth = function (passedConfigId, url) {
            if (this.currentUrlService.currentUrlHasStateParam()) {
                var stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();
                var config = this.getConfigurationWithUrlState(stateParamFromUrl);
                if (!config) {
                    return rxjs.throwError("could not find matching config for state " + stateParamFromUrl);
                }
                return this.checkAuthWithConfig(config, url);
            }
            if (!!passedConfigId) {
                var config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);
                return this.checkAuthWithConfig(config, url);
            }
            var onlyExistingConfig = this.configurationProvider.getOpenIDConfiguration();
            return this.checkAuthWithConfig(onlyExistingConfig, url);
        };
        CheckAuthService.prototype.checkAuthMultiple = function (passedConfigId, url) {
            var _this = this;
            if (this.currentUrlService.currentUrlHasStateParam()) {
                var stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();
                var config = this.getConfigurationWithUrlState(stateParamFromUrl);
                if (!config) {
                    return rxjs.throwError("could not find matching config for state " + stateParamFromUrl);
                }
                return this.composeMultipleLoginResults(config, url);
            }
            if (!!passedConfigId) {
                var config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);
                if (!config) {
                    return rxjs.throwError("could not find matching config for id " + passedConfigId);
                }
                return this.composeMultipleLoginResults(config, url);
            }
            var allConfigs = this.configurationProvider.getAllConfigurations();
            var allChecks$ = allConfigs.map(function (x) { return _this.checkAuthWithConfig(x, url); });
            return rxjs.forkJoin(allChecks$);
        };
        CheckAuthService.prototype.checkAuthIncludingServer = function (configId) {
            var _this = this;
            var config = this.configurationProvider.getOpenIDConfiguration(configId);
            return this.checkAuthWithConfig(config).pipe(operators.switchMap(function (loginResponse) {
                var isAuthenticated = loginResponse.isAuthenticated;
                if (isAuthenticated) {
                    return rxjs.of(loginResponse);
                }
                return _this.refreshSessionService.forceRefreshSession(configId).pipe(operators.tap(function (loginResponseAfterRefreshSession) {
                    if (loginResponseAfterRefreshSession === null || loginResponseAfterRefreshSession === void 0 ? void 0 : loginResponseAfterRefreshSession.isAuthenticated) {
                        _this.startCheckSessionAndValidation(configId);
                    }
                }));
            }));
        };
        CheckAuthService.prototype.checkAuthWithConfig = function (config, url) {
            var _this = this;
            var configId = config.configId, authority = config.authority;
            if (!this.configurationProvider.hasAsLeastOneConfig()) {
                var errorMessage = 'Please provide at least one configuration before setting up the module';
                this.loggerService.logError(configId, errorMessage);
                return rxjs.of({ isAuthenticated: false, errorMessage: errorMessage, userData: null, idToken: null, accessToken: null, configId: configId });
            }
            var currentUrl = url || this.currentUrlService.getCurrentUrl();
            this.loggerService.logDebug(configId, "Working with config '" + configId + "' using " + authority);
            if (this.popupService.isCurrentlyInPopup()) {
                this.popupService.sendMessageToMainWindow(currentUrl);
                return rxjs.of(null);
            }
            var isCallback = this.callbackService.isCallback(currentUrl);
            this.loggerService.logDebug(configId, 'currentUrl to check auth with: ', currentUrl);
            var callback$ = isCallback ? this.callbackService.handleCallbackAndFireEvents(currentUrl, configId) : rxjs.of(null);
            return callback$.pipe(operators.map(function () {
                var isAuthenticated = _this.authStateService.areAuthStorageTokensValid(configId);
                if (isAuthenticated) {
                    _this.startCheckSessionAndValidation(configId);
                    if (!isCallback) {
                        _this.authStateService.setAuthenticatedAndFireEvent();
                        _this.userService.publishUserDataIfExists(configId);
                    }
                }
                _this.loggerService.logDebug(configId, 'checkAuth completed - firing events now. isAuthenticated: ' + isAuthenticated);
                return {
                    isAuthenticated: isAuthenticated,
                    userData: _this.userService.getUserDataFromStore(configId),
                    accessToken: _this.authStateService.getAccessToken(configId),
                    idToken: _this.authStateService.getIdToken(configId),
                    configId: configId,
                };
            }), operators.tap(function (_a) {
                var isAuthenticated = _a.isAuthenticated;
                if (isAuthenticated) {
                    _this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);
                }
            }), operators.catchError(function (errorMessage) {
                _this.loggerService.logError(configId, errorMessage);
                return rxjs.of({ isAuthenticated: false, errorMessage: errorMessage, userData: null, idToken: null, accessToken: null, configId: configId });
            }));
        };
        CheckAuthService.prototype.startCheckSessionAndValidation = function (configId) {
            if (this.checkSessionService.isCheckSessionConfigured(configId)) {
                this.checkSessionService.start(configId);
            }
            this.periodicallyTokenCheckService.startTokenValidationPeriodically();
            if (this.silentRenewService.isSilentRenewConfigured(configId)) {
                this.silentRenewService.getOrCreateIframe(configId);
            }
        };
        CheckAuthService.prototype.getConfigurationWithUrlState = function (stateFromUrl) {
            var e_1, _a;
            var allConfigs = this.configurationProvider.getAllConfigurations();
            try {
                for (var allConfigs_1 = __values(allConfigs), allConfigs_1_1 = allConfigs_1.next(); !allConfigs_1_1.done; allConfigs_1_1 = allConfigs_1.next()) {
                    var config = allConfigs_1_1.value;
                    var storedState = this.storagePersistenceService.read('authStateControl', config.configId);
                    if (storedState === stateFromUrl) {
                        return config;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (allConfigs_1_1 && !allConfigs_1_1.done && (_a = allConfigs_1.return)) _a.call(allConfigs_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return null;
        };
        CheckAuthService.prototype.composeMultipleLoginResults = function (activeConfig, url) {
            var _this = this;
            var allOtherConfigs = this.configurationProvider.getAllConfigurations().filter(function (x) { return x.configId !== activeConfig.configId; });
            var currentConfigResult = this.checkAuthWithConfig(activeConfig, url);
            var allOtherConfigResults = allOtherConfigs.map(function (config) {
                var redirectUrl = config.redirectUrl;
                return _this.checkAuthWithConfig(config, redirectUrl);
            });
            return rxjs.forkJoin(__spreadArray([currentConfigResult], __read(allOtherConfigResults)));
        };
        return CheckAuthService;
    }());
    CheckAuthService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CheckAuthService, deps: [{ token: CheckSessionService }, { token: CurrentUrlService }, { token: SilentRenewService }, { token: UserService }, { token: LoggerService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: CallbackService }, { token: RefreshSessionService }, { token: PeriodicallyTokenCheckService }, { token: PopUpService }, { token: AutoLoginService }, { token: StoragePersistenceService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CheckAuthService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CheckAuthService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: CheckAuthService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: CheckSessionService }, { type: CurrentUrlService }, { type: SilentRenewService }, { type: UserService }, { type: LoggerService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: CallbackService }, { type: RefreshSessionService }, { type: PeriodicallyTokenCheckService }, { type: PopUpService }, { type: AutoLoginService }, { type: StoragePersistenceService }]; } });

    var DEFAULT_CONFIG = {
        authority: 'https://please_set',
        authWellknownEndpointUrl: '',
        authWellknownEndpoints: null,
        redirectUrl: 'https://please_set',
        clientId: 'please_set',
        responseType: 'code',
        scope: 'openid email profile',
        hdParam: '',
        postLogoutRedirectUri: 'https://please_set',
        startCheckSession: false,
        silentRenew: false,
        silentRenewUrl: 'https://please_set',
        silentRenewTimeoutInSeconds: 20,
        renewTimeBeforeTokenExpiresInSeconds: 0,
        useRefreshToken: false,
        usePushedAuthorisationRequests: false,
        ignoreNonceAfterRefresh: false,
        postLoginRoute: '/',
        forbiddenRoute: '/forbidden',
        unauthorizedRoute: '/unauthorized',
        autoUserInfo: true,
        autoCleanStateAfterAuthentication: true,
        triggerAuthorizationResultEvent: false,
        logLevel: exports.LogLevel.Warn,
        issValidationOff: false,
        historyCleanupOff: false,
        maxIdTokenIatOffsetAllowedInSeconds: 120,
        disableIatOffsetValidation: false,
        storage: null,
        customParamsAuthRequest: {},
        customParamsRefreshTokenRequest: {},
        customParamsEndSessionRequest: {},
        customParamsCodeRequest: {},
        eagerLoadAuthWellKnownEndpoints: true,
        disableRefreshIdTokenAuthTimeValidation: false,
        enableIdTokenExpiredValidationInRenew: true,
        tokenRefreshInSeconds: 4,
        refreshTokenRetryInSeconds: 3,
        ngswBypass: false,
    };

    var POSITIVE_VALIDATION_RESULT = {
        result: true,
        messages: [],
        level: null,
    };

    var ensureAuthority = function (passedConfig) {
        if (!passedConfig.authority) {
            return {
                result: false,
                messages: ['The authority URL MUST be provided in the configuration! '],
                level: 'error',
            };
        }
        return POSITIVE_VALIDATION_RESULT;
    };

    var ensureClientId = function (passedConfig) {
        if (!passedConfig.clientId) {
            return {
                result: false,
                messages: ['The clientId is required and missing from your config!'],
                level: 'error',
            };
        }
        return POSITIVE_VALIDATION_RESULT;
    };

    var createIdentifierToCheck = function (passedConfig) {
        if (!passedConfig) {
            return null;
        }
        var authority = passedConfig.authority, clientId = passedConfig.clientId, scope = passedConfig.scope;
        return "" + authority + clientId + scope;
    };
    var arrayHasDuplicates = function (array) { return new Set(array).size !== array.length; };
    var ensureNoDuplicatedConfigsRule = function (passedConfigs) {
        var allIdentifiers = passedConfigs.map(function (x) { return createIdentifierToCheck(x); });
        var someAreNull = allIdentifiers.some(function (x) { return x === null; });
        if (someAreNull) {
            return {
                result: false,
                messages: ["Please make sure you add an object with a 'config' property: ....({ config }) instead of ...(config)"],
                level: 'error',
            };
        }
        var hasDuplicates = arrayHasDuplicates(allIdentifiers);
        if (hasDuplicates) {
            return {
                result: false,
                messages: ['You added multiple configs with the same authority, clientId and scope'],
                level: 'warning',
            };
        }
        return POSITIVE_VALIDATION_RESULT;
    };

    var ensureRedirectRule = function (passedConfig) {
        if (!passedConfig.redirectUrl) {
            return {
                result: false,
                messages: ['The redirectURL is required and missing from your config'],
                level: 'error',
            };
        }
        return POSITIVE_VALIDATION_RESULT;
    };

    var ensureSilentRenewUrlWhenNoRefreshTokenUsed = function (passedConfig) {
        var usesSilentRenew = passedConfig.silentRenew;
        var usesRefreshToken = passedConfig.useRefreshToken;
        var hasSilentRenewUrl = passedConfig.silentRenewUrl;
        if (usesSilentRenew && !usesRefreshToken && !hasSilentRenewUrl) {
            return {
                result: false,
                messages: ['Please provide a silent renew URL if using renew and not refresh tokens'],
                level: 'error',
            };
        }
        return POSITIVE_VALIDATION_RESULT;
    };

    var useOfflineScopeWithSilentRenew = function (passedConfig) {
        var hasRefreshToken = passedConfig.useRefreshToken;
        var hasSilentRenew = passedConfig.silentRenew;
        var scope = passedConfig.scope || '';
        var hasOfflineScope = scope.split(' ').includes('offline_access');
        if (hasRefreshToken && hasSilentRenew && !hasOfflineScope) {
            return {
                result: false,
                messages: ['When using silent renew and refresh tokens please set the `offline_access` scope'],
                level: 'warning',
            };
        }
        return POSITIVE_VALIDATION_RESULT;
    };

    var allRules = [
        ensureAuthority,
        useOfflineScopeWithSilentRenew,
        ensureRedirectRule,
        ensureClientId,
        ensureSilentRenewUrlWhenNoRefreshTokenUsed,
    ];
    var allMultipleConfigRules = [ensureNoDuplicatedConfigsRule];

    var ConfigValidationService = /** @class */ (function () {
        function ConfigValidationService(loggerService) {
            this.loggerService = loggerService;
        }
        ConfigValidationService.prototype.validateConfigs = function (passedConfigs) {
            return this.validateConfigsInternal(passedConfigs, allMultipleConfigRules);
        };
        ConfigValidationService.prototype.validateConfig = function (passedConfig) {
            return this.validateConfigInternal(passedConfig, allRules);
        };
        ConfigValidationService.prototype.validateConfigsInternal = function (passedConfigs, allRulesToUse) {
            var _this = this;
            var allValidationResults = allRulesToUse.map(function (rule) { return rule(passedConfigs); });
            var overallErrorCount = 0;
            passedConfigs.forEach(function (passedConfig) {
                var errorCount = _this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.configId);
                overallErrorCount += errorCount;
            });
            return overallErrorCount === 0;
        };
        ConfigValidationService.prototype.validateConfigInternal = function (passedConfig, allRulesToUse) {
            var allValidationResults = allRulesToUse.map(function (rule) { return rule(passedConfig); });
            var errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig.configId);
            return errorCount === 0;
        };
        ConfigValidationService.prototype.processValidationResultsAndGetErrorCount = function (allValidationResults, configId) {
            var _this = this;
            var allMessages = allValidationResults.filter(function (x) { return x.messages.length > 0; });
            var allErrorMessages = this.getAllMessagesOfType('error', allMessages);
            var allWarnings = this.getAllMessagesOfType('warning', allMessages);
            allErrorMessages.forEach(function (message) { return _this.loggerService.logError(configId, message); });
            allWarnings.forEach(function (message) { return _this.loggerService.logWarning(configId, message); });
            return allErrorMessages.length;
        };
        ConfigValidationService.prototype.getAllMessagesOfType = function (type, results) {
            var allMessages = results.filter(function (x) { return x.level === type; }).map(function (result) { return result.messages; });
            return allMessages.reduce(function (acc, val) { return acc.concat(val); }, []);
        };
        return ConfigValidationService;
    }());
    ConfigValidationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ConfigValidationService, deps: [{ token: LoggerService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ConfigValidationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ConfigValidationService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ConfigValidationService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: LoggerService }]; } });

    var PlatformProvider = /** @class */ (function () {
        function PlatformProvider(platformId) {
            this.platformId = platformId;
        }
        Object.defineProperty(PlatformProvider.prototype, "isBrowser", {
            get: function () {
                return common.isPlatformBrowser(this.platformId);
            },
            enumerable: false,
            configurable: true
        });
        return PlatformProvider;
    }());
    PlatformProvider.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PlatformProvider, deps: [{ token: i0.PLATFORM_ID }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PlatformProvider.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PlatformProvider });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PlatformProvider, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }];
        } });

    var DefaultSessionStorageService = /** @class */ (function () {
        function DefaultSessionStorageService() {
        }
        DefaultSessionStorageService.prototype.read = function (key) {
            return sessionStorage.getItem(key);
        };
        DefaultSessionStorageService.prototype.write = function (key, value) {
            sessionStorage.setItem(key, value);
        };
        DefaultSessionStorageService.prototype.remove = function (key) {
            sessionStorage.removeItem(key);
        };
        DefaultSessionStorageService.prototype.clear = function () {
            sessionStorage.clear();
        };
        return DefaultSessionStorageService;
    }());
    DefaultSessionStorageService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: DefaultSessionStorageService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DefaultSessionStorageService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: DefaultSessionStorageService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: DefaultSessionStorageService, decorators: [{
                type: i0.Injectable
            }] });

    var OidcConfigService = /** @class */ (function () {
        function OidcConfigService(loggerService, publicEventsService, configurationProvider, authWellKnownService, storagePersistenceService, configValidationService, platformProvider, defaultSessionStorageService) {
            this.loggerService = loggerService;
            this.publicEventsService = publicEventsService;
            this.configurationProvider = configurationProvider;
            this.authWellKnownService = authWellKnownService;
            this.storagePersistenceService = storagePersistenceService;
            this.configValidationService = configValidationService;
            this.platformProvider = platformProvider;
            this.defaultSessionStorageService = defaultSessionStorageService;
        }
        OidcConfigService.prototype.withConfigs = function (passedConfigs) {
            var _this = this;
            if (!this.configValidationService.validateConfigs(passedConfigs)) {
                return Promise.resolve(null);
            }
            this.createUniqueIds(passedConfigs);
            var allHandleConfigPromises = passedConfigs.map(function (x) { return _this.handleConfig(x); });
            return Promise.all(allHandleConfigPromises);
        };
        OidcConfigService.prototype.createUniqueIds = function (passedConfigs) {
            passedConfigs.forEach(function (config, index) {
                if (!config.configId) {
                    config.configId = index + "-" + config.clientId;
                }
            });
        };
        OidcConfigService.prototype.handleConfig = function (passedConfig) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (!_this.configValidationService.validateConfig(passedConfig)) {
                    _this.loggerService.logError(passedConfig.configId, 'Validation of config rejected with errors. Config is NOT set.');
                    resolve(null);
                    return;
                }
                if (!passedConfig.authWellknownEndpointUrl) {
                    passedConfig.authWellknownEndpointUrl = passedConfig.authority;
                }
                var usedConfig = _this.prepareConfig(passedConfig);
                _this.configurationProvider.setConfig(usedConfig);
                var alreadyExistingAuthWellKnownEndpoints = _this.storagePersistenceService.read('authWellKnownEndPoints', usedConfig.configId);
                if (!!alreadyExistingAuthWellKnownEndpoints) {
                    usedConfig.authWellknownEndpoints = alreadyExistingAuthWellKnownEndpoints;
                    _this.publicEventsService.fireEvent(exports.EventTypes.ConfigLoaded, usedConfig);
                    resolve(usedConfig);
                    return;
                }
                var passedAuthWellKnownEndpoints = usedConfig.authWellknownEndpoints;
                if (!!passedAuthWellKnownEndpoints) {
                    _this.authWellKnownService.storeWellKnownEndpoints(usedConfig.configId, passedAuthWellKnownEndpoints);
                    usedConfig.authWellknownEndpoints = passedAuthWellKnownEndpoints;
                    _this.publicEventsService.fireEvent(exports.EventTypes.ConfigLoaded, usedConfig);
                    resolve(usedConfig);
                    return;
                }
                if (usedConfig.eagerLoadAuthWellKnownEndpoints) {
                    _this.authWellKnownService
                        .getAuthWellKnownEndPoints(usedConfig.authWellknownEndpointUrl, usedConfig.configId)
                        .pipe(operators.catchError(function (error) {
                        _this.loggerService.logError(usedConfig.configId, 'Getting auth well known endpoints failed on start', error);
                        return rxjs.throwError(error);
                    }), operators.tap(function (wellknownEndPoints) {
                        usedConfig.authWellknownEndpoints = wellknownEndPoints;
                        _this.publicEventsService.fireEvent(exports.EventTypes.ConfigLoaded, usedConfig);
                    }))
                        .subscribe(function () { return resolve(usedConfig); }, function () { return reject(); });
                }
                else {
                    _this.publicEventsService.fireEvent(exports.EventTypes.ConfigLoaded, usedConfig);
                    resolve(usedConfig);
                }
            });
        };
        OidcConfigService.prototype.prepareConfig = function (configuration) {
            var openIdConfigurationInternal = Object.assign(Object.assign({}, DEFAULT_CONFIG), configuration);
            this.setSpecialCases(openIdConfigurationInternal);
            this.setStorage(openIdConfigurationInternal);
            return openIdConfigurationInternal;
        };
        OidcConfigService.prototype.setSpecialCases = function (currentConfig) {
            if (!this.platformProvider.isBrowser) {
                currentConfig.startCheckSession = false;
                currentConfig.silentRenew = false;
                currentConfig.useRefreshToken = false;
                currentConfig.usePushedAuthorisationRequests = false;
            }
        };
        OidcConfigService.prototype.setStorage = function (currentConfig) {
            if (currentConfig.storage) {
                return;
            }
            if (this.hasBrowserStorage()) {
                currentConfig.storage = this.defaultSessionStorageService;
            }
            else {
                currentConfig.storage = null;
            }
        };
        OidcConfigService.prototype.hasBrowserStorage = function () {
            return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';
        };
        return OidcConfigService;
    }());
    OidcConfigService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: OidcConfigService, deps: [{ token: LoggerService }, { token: PublicEventsService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }, { token: StoragePersistenceService }, { token: ConfigValidationService }, { token: PlatformProvider }, { token: DefaultSessionStorageService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OidcConfigService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: OidcConfigService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: OidcConfigService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: LoggerService }, { type: PublicEventsService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }, { type: StoragePersistenceService }, { type: ConfigValidationService }, { type: PlatformProvider }, { type: DefaultSessionStorageService }]; } });

    var OpenIdConfigLoader = /** @class */ (function () {
        function OpenIdConfigLoader() {
        }
        return OpenIdConfigLoader;
    }());
    var StsConfigLoader = /** @class */ (function () {
        function StsConfigLoader() {
        }
        return StsConfigLoader;
    }());
    var StsConfigStaticLoader = /** @class */ (function () {
        function StsConfigStaticLoader(passedConfigs) {
            this.passedConfigs = passedConfigs;
        }
        StsConfigStaticLoader.prototype.loadConfigs = function () {
            var _this = this;
            if (Array.isArray(this.passedConfigs)) {
                var allInstantStaticPromises = this.passedConfigs.map(function (x) { return new Promise(function (resolve, _) { return resolve(x); }); });
                return allInstantStaticPromises;
            }
            var singleStaticPromise = new Promise(function (resolve, _) { return resolve(_this.passedConfigs); });
            return [singleStaticPromise];
        };
        return StsConfigStaticLoader;
    }());
    var StsConfigHttpLoader = /** @class */ (function () {
        function StsConfigHttpLoader(configs$) {
            this.configs$ = configs$;
        }
        StsConfigHttpLoader.prototype.loadConfigs = function () {
            return Array.isArray(this.configs$) ? this.configs$ : [this.configs$];
        };
        return StsConfigHttpLoader;
    }());

    var ClosestMatchingRouteService = /** @class */ (function () {
        function ClosestMatchingRouteService(configProvider) {
            this.configProvider = configProvider;
        }
        ClosestMatchingRouteService.prototype.getConfigIdForClosestMatchingRoute = function (route) {
            var e_1, _a, e_2, _b;
            var allConfiguredRoutes = this.getAllConfiguredRoutes();
            try {
                for (var allConfiguredRoutes_1 = __values(allConfiguredRoutes), allConfiguredRoutes_1_1 = allConfiguredRoutes_1.next(); !allConfiguredRoutes_1_1.done; allConfiguredRoutes_1_1 = allConfiguredRoutes_1.next()) {
                    var routesWithConfig = allConfiguredRoutes_1_1.value;
                    var allRoutesForConfig = routesWithConfig.routes;
                    try {
                        for (var allRoutesForConfig_1 = (e_2 = void 0, __values(allRoutesForConfig)), allRoutesForConfig_1_1 = allRoutesForConfig_1.next(); !allRoutesForConfig_1_1.done; allRoutesForConfig_1_1 = allRoutesForConfig_1.next()) {
                            var configuredRoute = allRoutesForConfig_1_1.value;
                            if (route.startsWith(configuredRoute)) {
                                return {
                                    matchingRoute: configuredRoute,
                                    matchingConfigId: routesWithConfig.configId,
                                };
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (allRoutesForConfig_1_1 && !allRoutesForConfig_1_1.done && (_b = allRoutesForConfig_1.return)) _b.call(allRoutesForConfig_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (allConfiguredRoutes_1_1 && !allConfiguredRoutes_1_1.done && (_a = allConfiguredRoutes_1.return)) _a.call(allConfiguredRoutes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return {
                matchingRoute: null,
                matchingConfigId: null,
            };
        };
        ClosestMatchingRouteService.prototype.getAllConfiguredRoutes = function () {
            var allConfigurations = this.configProvider.getAllConfigurations();
            return allConfigurations.map(function (x) { return ({ routes: x.secureRoutes, configId: x.configId }); });
        };
        return ClosestMatchingRouteService;
    }());
    ClosestMatchingRouteService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ClosestMatchingRouteService, deps: [{ token: ConfigurationProvider }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ClosestMatchingRouteService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ClosestMatchingRouteService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ClosestMatchingRouteService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: ConfigurationProvider }]; } });

    var ResponseTypeValidationService = /** @class */ (function () {
        function ResponseTypeValidationService(loggerService, flowHelper) {
            this.loggerService = loggerService;
            this.flowHelper = flowHelper;
        }
        ResponseTypeValidationService.prototype.hasConfigValidResponseType = function (configId) {
            if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {
                return true;
            }
            if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {
                return true;
            }
            this.loggerService.logWarning(configId, 'module configured incorrectly, invalid response_type. Check the responseType in the config');
            return false;
        };
        return ResponseTypeValidationService;
    }());
    ResponseTypeValidationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ResponseTypeValidationService, deps: [{ token: LoggerService }, { token: FlowHelper }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ResponseTypeValidationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ResponseTypeValidationService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ResponseTypeValidationService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: LoggerService }, { type: FlowHelper }]; } });

    var RedirectService = /** @class */ (function () {
        function RedirectService(doc) {
            this.doc = doc;
        }
        RedirectService.prototype.redirectTo = function (url) {
            this.doc.location.href = url;
        };
        return RedirectService;
    }());
    RedirectService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RedirectService, deps: [{ token: common.DOCUMENT }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    RedirectService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RedirectService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: RedirectService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [common.DOCUMENT]
                        }] }];
        } });

    var ParService = /** @class */ (function () {
        function ParService(loggerService, urlService, dataService, storagePersistenceService) {
            this.loggerService = loggerService;
            this.urlService = urlService;
            this.dataService = dataService;
            this.storagePersistenceService = storagePersistenceService;
        }
        ParService.prototype.postParRequest = function (configId, customParams) {
            var _this = this;
            var headers = new i1.HttpHeaders();
            headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');
            var authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);
            if (!authWellknownEndpoints) {
                return rxjs.throwError('Could not read PAR endpoint because authWellKnownEndPoints are not given');
            }
            var parEndpoint = authWellknownEndpoints.parEndpoint;
            if (!parEndpoint) {
                return rxjs.throwError('Could not read PAR endpoint from authWellKnownEndpoints');
            }
            var data = this.urlService.createBodyForParCodeFlowRequest(configId, customParams);
            return this.dataService.post(parEndpoint, data, configId, headers).pipe(operators.retry(2), operators.map(function (response) {
                _this.loggerService.logDebug(configId, 'par response: ', response);
                return {
                    expiresIn: response.expires_in,
                    requestUri: response.request_uri,
                };
            }), operators.catchError(function (error) {
                var errorMessage = "There was an error on ParService postParRequest";
                _this.loggerService.logError(configId, errorMessage, error);
                return rxjs.throwError(errorMessage);
            }));
        };
        return ParService;
    }());
    ParService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ParService, deps: [{ token: LoggerService }, { token: UrlService }, { token: DataService }, { token: StoragePersistenceService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ParService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ParService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ParService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: LoggerService }, { type: UrlService }, { type: DataService }, { type: StoragePersistenceService }]; } });

    var ParLoginService = /** @class */ (function () {
        function ParLoginService(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService, popupService, checkAuthService, parService) {
            this.loggerService = loggerService;
            this.responseTypeValidationService = responseTypeValidationService;
            this.urlService = urlService;
            this.redirectService = redirectService;
            this.configurationProvider = configurationProvider;
            this.authWellKnownService = authWellKnownService;
            this.popupService = popupService;
            this.checkAuthService = checkAuthService;
            this.parService = parService;
        }
        ParLoginService.prototype.loginPar = function (configId, authOptions) {
            var _this = this;
            if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {
                this.loggerService.logError(configId, 'Invalid response type!');
                return;
            }
            var authWellknownEndpointUrl = this.configurationProvider.getOpenIDConfiguration(configId).authWellknownEndpointUrl;
            if (!authWellknownEndpointUrl) {
                this.loggerService.logError(configId, 'no authWellknownEndpoint given!');
                return;
            }
            this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');
            var _a = authOptions || {}, urlHandler = _a.urlHandler, customParams = _a.customParams;
            this.authWellKnownService
                .getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId)
                .pipe(operators.switchMap(function () { return _this.parService.postParRequest(configId, customParams); }))
                .subscribe(function (response) {
                _this.loggerService.logDebug(configId, 'par response: ', response);
                var url = _this.urlService.getAuthorizeParUrl(response.requestUri, configId);
                _this.loggerService.logDebug(configId, 'par request url: ', url);
                if (!url) {
                    _this.loggerService.logError(configId, "Could not create URL with param " + response.requestUri + ": '" + url + "'");
                    return;
                }
                if (urlHandler) {
                    urlHandler(url);
                }
                else {
                    _this.redirectService.redirectTo(url);
                }
            });
        };
        ParLoginService.prototype.loginWithPopUpPar = function (configId, authOptions, popupOptions) {
            var _this = this;
            if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {
                var errorMessage = 'Invalid response type!';
                this.loggerService.logError(configId, errorMessage);
                return rxjs.throwError(errorMessage);
            }
            var authWellknownEndpointUrl = this.configurationProvider.getOpenIDConfiguration(configId).authWellknownEndpointUrl;
            if (!authWellknownEndpointUrl) {
                var errorMessage = 'no authWellknownEndpoint given!';
                this.loggerService.logError(configId, errorMessage);
                return rxjs.throwError(errorMessage);
            }
            this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');
            var customParams = (authOptions || {}).customParams;
            return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(operators.switchMap(function () { return _this.parService.postParRequest(configId, customParams); }), operators.switchMap(function (response) {
                _this.loggerService.logDebug(configId, 'par response: ', response);
                var url = _this.urlService.getAuthorizeParUrl(response.requestUri, configId);
                _this.loggerService.logDebug(configId, 'par request url: ', url);
                if (!url) {
                    var errorMessage = "Could not create URL with param " + response.requestUri + ": 'url'";
                    _this.loggerService.logError(configId, errorMessage);
                    return rxjs.throwError(errorMessage);
                }
                _this.popupService.openPopUp(url, popupOptions);
                return _this.popupService.result$.pipe(operators.take(1), operators.switchMap(function (result) {
                    var userClosed = result.userClosed, receivedUrl = result.receivedUrl;
                    if (userClosed) {
                        return rxjs.of({
                            isAuthenticated: false,
                            errorMessage: 'User closed popup',
                            userData: null,
                            idToken: null,
                            accessToken: null,
                            configId: configId,
                        });
                    }
                    return _this.checkAuthService.checkAuth(configId, receivedUrl);
                }));
            }));
        };
        return ParLoginService;
    }());
    ParLoginService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ParLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: RedirectService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }, { token: PopUpService }, { token: CheckAuthService }, { token: ParService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ParLoginService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ParLoginService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: ParLoginService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: RedirectService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }, { type: PopUpService }, { type: CheckAuthService }, { type: ParService }]; } });

    var PopUpLoginService = /** @class */ (function () {
        function PopUpLoginService(loggerService, responseTypeValidationService, urlService, configurationProvider, authWellKnownService, popupService, checkAuthService) {
            this.loggerService = loggerService;
            this.responseTypeValidationService = responseTypeValidationService;
            this.urlService = urlService;
            this.configurationProvider = configurationProvider;
            this.authWellKnownService = authWellKnownService;
            this.popupService = popupService;
            this.checkAuthService = checkAuthService;
        }
        PopUpLoginService.prototype.loginWithPopUpStandard = function (configId, authOptions, popupOptions) {
            var _this = this;
            if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {
                var errorMessage = 'Invalid response type!';
                this.loggerService.logError(configId, errorMessage);
                return rxjs.throwError(errorMessage);
            }
            var authWellknownEndpointUrl = this.configurationProvider.getOpenIDConfiguration(configId).authWellknownEndpointUrl;
            if (!authWellknownEndpointUrl) {
                var errorMessage = 'no authWellknownEndpoint given!';
                this.loggerService.logError(configId, errorMessage);
                return rxjs.throwError(errorMessage);
            }
            this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');
            return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(operators.switchMap(function () {
                var customParams = (authOptions || {}).customParams;
                var authUrl = _this.urlService.getAuthorizeUrl(configId, customParams);
                _this.popupService.openPopUp(authUrl, popupOptions);
                return _this.popupService.result$.pipe(operators.take(1), operators.switchMap(function (result) {
                    var userClosed = result.userClosed, receivedUrl = result.receivedUrl;
                    if (userClosed) {
                        return rxjs.of({
                            isAuthenticated: false,
                            errorMessage: 'User closed popup',
                            userData: null,
                            idToken: null,
                            accessToken: null,
                            configId: configId,
                        });
                    }
                    return _this.checkAuthService.checkAuth(configId, receivedUrl);
                }));
            }));
        };
        return PopUpLoginService;
    }());
    PopUpLoginService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PopUpLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }, { token: PopUpService }, { token: CheckAuthService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    PopUpLoginService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PopUpLoginService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: PopUpLoginService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }, { type: PopUpService }, { type: CheckAuthService }]; } });

    var StandardLoginService = /** @class */ (function () {
        function StandardLoginService(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService) {
            this.loggerService = loggerService;
            this.responseTypeValidationService = responseTypeValidationService;
            this.urlService = urlService;
            this.redirectService = redirectService;
            this.configurationProvider = configurationProvider;
            this.authWellKnownService = authWellKnownService;
        }
        StandardLoginService.prototype.loginStandard = function (configId, authOptions) {
            var _this = this;
            if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {
                this.loggerService.logError(configId, 'Invalid response type!');
                return;
            }
            var authWellknownEndpointUrl = this.configurationProvider.getOpenIDConfiguration(configId).authWellknownEndpointUrl;
            if (!authWellknownEndpointUrl) {
                this.loggerService.logError(configId, 'no authWellknownEndpoint given!');
                return;
            }
            this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');
            this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).subscribe(function () {
                var _a = authOptions || {}, urlHandler = _a.urlHandler, customParams = _a.customParams;
                var url = _this.urlService.getAuthorizeUrl(configId, customParams);
                if (!url) {
                    _this.loggerService.logError(configId, 'Could not create URL', url);
                    return;
                }
                if (urlHandler) {
                    urlHandler(url);
                }
                else {
                    _this.redirectService.redirectTo(url);
                }
            });
        };
        return StandardLoginService;
    }());
    StandardLoginService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: StandardLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: RedirectService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    StandardLoginService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: StandardLoginService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: StandardLoginService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: RedirectService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }]; } });

    var LoginService = /** @class */ (function () {
        function LoginService(configurationProvider, parLoginService, popUpLoginService, standardLoginService, storagePersistenceService) {
            this.configurationProvider = configurationProvider;
            this.parLoginService = parLoginService;
            this.popUpLoginService = popUpLoginService;
            this.standardLoginService = standardLoginService;
            this.storagePersistenceService = storagePersistenceService;
        }
        LoginService.prototype.login = function (configId, authOptions) {
            if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {
                this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);
            }
            var usePushedAuthorisationRequests = this.configurationProvider.getOpenIDConfiguration(configId).usePushedAuthorisationRequests;
            if (usePushedAuthorisationRequests) {
                return this.parLoginService.loginPar(configId, authOptions);
            }
            else {
                return this.standardLoginService.loginStandard(configId, authOptions);
            }
        };
        LoginService.prototype.loginWithPopUp = function (configId, authOptions, popupOptions) {
            if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {
                this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);
            }
            var usePushedAuthorisationRequests = this.configurationProvider.getOpenIDConfiguration(configId).usePushedAuthorisationRequests;
            if (usePushedAuthorisationRequests) {
                return this.parLoginService.loginWithPopUpPar(configId, authOptions, popupOptions);
            }
            else {
                return this.popUpLoginService.loginWithPopUpStandard(configId, authOptions, popupOptions);
            }
        };
        return LoginService;
    }());
    LoginService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: LoginService, deps: [{ token: ConfigurationProvider }, { token: ParLoginService }, { token: PopUpLoginService }, { token: StandardLoginService }, { token: StoragePersistenceService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LoginService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: LoginService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: LoginService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: ParLoginService }, { type: PopUpLoginService }, { type: StandardLoginService }, { type: StoragePersistenceService }]; } });

    var LogoffRevocationService = /** @class */ (function () {
        function LogoffRevocationService(dataService, storagePersistenceService, loggerService, urlService, checkSessionService, resetAuthDataService, redirectService, configurationProvider) {
            this.dataService = dataService;
            this.storagePersistenceService = storagePersistenceService;
            this.loggerService = loggerService;
            this.urlService = urlService;
            this.checkSessionService = checkSessionService;
            this.resetAuthDataService = resetAuthDataService;
            this.redirectService = redirectService;
            this.configurationProvider = configurationProvider;
        }
        // Logs out on the server and the local client.
        // If the server state has changed, check session, then only a local logout.
        LogoffRevocationService.prototype.logoff = function (configId, authOptions) {
            var _a = authOptions || {}, urlHandler = _a.urlHandler, customParams = _a.customParams;
            this.loggerService.logDebug(configId, 'logoff, remove auth ');
            var endSessionUrl = this.getEndSessionUrl(configId, customParams);
            this.resetAuthDataService.resetAuthorizationData(configId);
            if (!endSessionUrl) {
                this.loggerService.logDebug(configId, 'only local login cleaned up, no end_session_endpoint');
                return;
            }
            if (this.checkSessionService.serverStateChanged(configId)) {
                this.loggerService.logDebug(configId, 'only local login cleaned up, server session has changed');
            }
            else if (urlHandler) {
                urlHandler(endSessionUrl);
            }
            else {
                this.redirectService.redirectTo(endSessionUrl);
            }
        };
        LogoffRevocationService.prototype.logoffLocal = function (configId) {
            this.resetAuthDataService.resetAuthorizationData(configId);
            this.checkSessionService.stop();
        };
        LogoffRevocationService.prototype.logoffLocalMultiple = function () {
            var _this = this;
            var allConfigs = this.configurationProvider.getAllConfigurations();
            allConfigs.forEach(function (_a) {
                var configId = _a.configId;
                return _this.logoffLocal(configId);
            });
        };
        // The refresh token and and the access token are revoked on the server. If the refresh token does not exist
        // only the access token is revoked. Then the logout run.
        LogoffRevocationService.prototype.logoffAndRevokeTokens = function (configId, authOptions) {
            var _this = this;
            var revocationEndpoint = (this.storagePersistenceService.read('authWellKnownEndPoints', configId) || {}).revocationEndpoint;
            if (!revocationEndpoint) {
                this.loggerService.logDebug(configId, 'revocation endpoint not supported');
                this.logoff(configId, authOptions);
            }
            if (this.storagePersistenceService.getRefreshToken(configId)) {
                return this.revokeRefreshToken(configId).pipe(operators.switchMap(function (result) { return _this.revokeAccessToken(configId, result); }), operators.catchError(function (error) {
                    var errorMessage = "revoke token failed";
                    _this.loggerService.logError(configId, errorMessage, error);
                    return rxjs.throwError(errorMessage);
                }), operators.tap(function () { return _this.logoff(configId, authOptions); }));
            }
            else {
                return this.revokeAccessToken(configId).pipe(operators.catchError(function (error) {
                    var errorMessage = "revoke accessToken failed";
                    _this.loggerService.logError(configId, errorMessage, error);
                    return rxjs.throwError(errorMessage);
                }), operators.tap(function () { return _this.logoff(configId, authOptions); }));
            }
        };
        // https://tools.ietf.org/html/rfc7009
        // revokes an access token on the STS. If no token is provided, then the token from
        // the storage is revoked. You can pass any token to revoke. This makes it possible to
        // manage your own tokens. The is a public API.
        LogoffRevocationService.prototype.revokeAccessToken = function (configId, accessToken) {
            var accessTok = accessToken || this.storagePersistenceService.getAccessToken(configId);
            var body = this.urlService.createRevocationEndpointBodyAccessToken(accessTok, configId);
            return this.sendRevokeRequest(configId, body);
        };
        // https://tools.ietf.org/html/rfc7009
        // revokes an refresh token on the STS. This is only required in the code flow with refresh tokens.
        // If no token is provided, then the token from the storage is revoked. You can pass any token to revoke.
        // This makes it possible to manage your own tokens.
        LogoffRevocationService.prototype.revokeRefreshToken = function (configId, refreshToken) {
            var refreshTok = refreshToken || this.storagePersistenceService.getRefreshToken(configId);
            var body = this.urlService.createRevocationEndpointBodyRefreshToken(refreshTok, configId);
            return this.sendRevokeRequest(configId, body);
        };
        LogoffRevocationService.prototype.getEndSessionUrl = function (configId, customParams) {
            var idToken = this.storagePersistenceService.getIdToken(configId);
            var customParamsEndSessionRequest = this.configurationProvider.getOpenIDConfiguration().customParamsEndSessionRequest;
            var mergedParams = Object.assign(Object.assign({}, customParamsEndSessionRequest), customParams);
            return this.urlService.createEndSessionUrl(idToken, configId, mergedParams);
        };
        LogoffRevocationService.prototype.sendRevokeRequest = function (configId, body) {
            var _this = this;
            var url = this.urlService.getRevocationEndpointUrl(configId);
            var headers = new i1.HttpHeaders();
            headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');
            return this.dataService.post(url, body, configId, headers).pipe(operators.retry(2), operators.switchMap(function (response) {
                _this.loggerService.logDebug(configId, 'revocation endpoint post response: ', response);
                return rxjs.of(response);
            }), operators.catchError(function (error) {
                var errorMessage = "Revocation request failed";
                _this.loggerService.logError(configId, errorMessage, error);
                return rxjs.throwError(errorMessage);
            }));
        };
        return LogoffRevocationService;
    }());
    LogoffRevocationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: LogoffRevocationService, deps: [{ token: DataService }, { token: StoragePersistenceService }, { token: LoggerService }, { token: UrlService }, { token: CheckSessionService }, { token: ResetAuthDataService }, { token: RedirectService }, { token: ConfigurationProvider }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LogoffRevocationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: LogoffRevocationService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: LogoffRevocationService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: DataService }, { type: StoragePersistenceService }, { type: LoggerService }, { type: UrlService }, { type: CheckSessionService }, { type: ResetAuthDataService }, { type: RedirectService }, { type: ConfigurationProvider }]; } });

    var OidcSecurityService = /** @class */ (function () {
        function OidcSecurityService(checkSessionService, checkAuthService, userService, tokenHelperService, configurationProvider, authStateService, flowsDataService, callbackService, logoffRevocationService, loginService, refreshSessionService, urlService) {
            this.checkSessionService = checkSessionService;
            this.checkAuthService = checkAuthService;
            this.userService = userService;
            this.tokenHelperService = tokenHelperService;
            this.configurationProvider = configurationProvider;
            this.authStateService = authStateService;
            this.flowsDataService = flowsDataService;
            this.callbackService = callbackService;
            this.logoffRevocationService = logoffRevocationService;
            this.loginService = loginService;
            this.refreshSessionService = refreshSessionService;
            this.urlService = urlService;
        }
        Object.defineProperty(OidcSecurityService.prototype, "userData$", {
            /**
             * Provides information about the user after they have logged in.
             *
             * @returns Returns an object containing either the user data directly (single config) or
             * the user data per config in case you are running with multiple configs
             */
            get: function () {
                return this.userService.userData$;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(OidcSecurityService.prototype, "isAuthenticated$", {
            /**
             * Emits each time an authorization event occurs.
             *
             * @returns Returns an object containing if you are authenticated or not.
             * Single Config: true if config is authenticated, false if not.
             * Multiple Configs: true is all configs are authenticated, false if only one of them is not
             *
             * The `allConfigsAuthenticated` property contains the auth information _per config_.
             */
            get: function () {
                return this.authStateService.authenticated$;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(OidcSecurityService.prototype, "checkSessionChanged$", {
            /**
             * Emits each time the server sends a CheckSession event and the value changed. This property will always return
             * true.
             */
            get: function () {
                return this.checkSessionService.checkSessionChanged$;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(OidcSecurityService.prototype, "stsCallback$", {
            /**
             * Emits on a Security Token Service callback. The observable will never contain a value.
             */
            get: function () {
                return this.callbackService.stsCallback$;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns the currently active OpenID configurations.
         *
         * @returns an array of OpenIdConfigurations.
         */
        OidcSecurityService.prototype.getConfigurations = function () {
            return this.configurationProvider.getAllConfigurations();
        };
        /**
         * Returns a single active OpenIdConfiguration.
         *
         * @param configId The configId to identify the config. If not passed, the first one is being returned
         */
        OidcSecurityService.prototype.getConfiguration = function (configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;
            return this.configurationProvider.getOpenIDConfiguration(configId);
        };
        /**
         * Returns the userData for a configuration
         *
         * @param configId The configId to identify the config. If not passed, the first one is being used
         */
        OidcSecurityService.prototype.getUserData = function (configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;
            return this.userService.getUserDataFromStore(configId);
        };
        /**
         * Starts the complete setup flow for one configuration. Calling will start the entire authentication flow, and the returned observable
         * will denote whether the user was successfully authenticated including the user data, the access token, the configId and
         * an error message in case an error happened
         *
         * @param url The URL to perform the authorization on the behalf of.
         * @param configId The configId to perform the authorization on the behalf of. If not passed, the first configs will be taken
         *
         * @returns An object `LoginResponse` containing all information about the login
         */
        OidcSecurityService.prototype.checkAuth = function (url, configId) {
            return this.checkAuthService.checkAuth(configId, url);
        };
        /**
         * Starts the complete setup flow for multiple configurations.
         * Calling will start the entire authentication flow, and the returned observable
         * will denote whether the user was successfully authenticated including the user data, the access token, the configId and
         * an error message in case an error happened in an array for each config which was provided
         *
         * @param url The URL to perform the authorization on the behalf of.
         * @param configId The configId to perform the authorization on the behalf of. If not passed, all of the current
         * configured ones will be used to check.
         *
         * @returns An array of `LoginResponse` objects containing all information about the logins
         */
        OidcSecurityService.prototype.checkAuthMultiple = function (url, configId) {
            return this.checkAuthService.checkAuthMultiple(configId, url);
        };
        /**
         * Provides information about the current authenticated state
         *
         * @param configId The configId to check the information for. If not passed, the first configs will be taken
         *
         * @returns A boolean whether the config is authenticated or not.
         */
        OidcSecurityService.prototype.isAuthenticated = function (configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.authStateService.isAuthenticated(configId);
        };
        /**
         * Checks the server for an authenticated session using the iframe silent renew if not locally authenticated.
         */
        OidcSecurityService.prototype.checkAuthIncludingServer = function (configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.checkAuthService.checkAuthIncludingServer(configId);
        };
        /**
         * Returns the access token for the login scenario.
         *
         * @param configId The configId to check the information for. If not passed, the first configs will be taken
         *
         * @returns A string with the access token.
         */
        OidcSecurityService.prototype.getAccessToken = function (configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.authStateService.getAccessToken(configId);
        };
        /**
         * Returns the ID token for the sign-in.
         *
         * @param configId The configId to check the information for. If not passed, the first configs will be taken
         *
         * @returns A string with the id token.
         */
        OidcSecurityService.prototype.getIdToken = function (configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.authStateService.getIdToken(configId);
        };
        /**
         * Returns the refresh token, if present, for the sign-in.
         *
         * @param configId The configId to check the information for. If not passed, the first configs will be taken
         *
         * @returns A string with the refresh token.
         */
        OidcSecurityService.prototype.getRefreshToken = function (configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.authStateService.getRefreshToken(configId);
        };
        /**
         * Returns the authentication result, if present, for the sign-in.
         *
         * @param configId The configId to check the information for. If not passed, the first configs will be taken
         *
         * @returns A object with the authentication result
         */
        OidcSecurityService.prototype.getAuthenticationResult = function (configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.authStateService.getAuthenticationResult(configId);
        };
        /**
         * Returns the payload from the ID token.
         *
         * @param encode Set to true if the payload is base64 encoded
         * @param configId The configId to check the information for. If not passed, the first configs will be taken
         *
         * @returns The payload from the id token.
         */
        OidcSecurityService.prototype.getPayloadFromIdToken = function (encode, configId) {
            if (encode === void 0) { encode = false; }
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            var token = this.authStateService.getIdToken(configId);
            return this.tokenHelperService.getPayloadFromToken(token, encode, configId);
        };
        /**
         * Sets a custom state for the authorize request.
         *
         * @param state The state to set.
         * @param configId The configId to check the information for. If not passed, the first configs will be taken
         */
        OidcSecurityService.prototype.setState = function (state, configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            this.flowsDataService.setAuthStateControl(state, configId);
        };
        /**
         * Gets the state value used for the authorize request.
         *
         * @param configId The configId to check the information for. If not passed, the first configs will be taken
         *
         * @returns The state value used for the authorize request.
         */
        OidcSecurityService.prototype.getState = function (configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.flowsDataService.getAuthStateControl(configId);
        };
        /**
         * Redirects the user to the Security Token Service to begin the authentication process.
         *
         * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken
         * @param authOptions The custom options for the the authentication request.
         */
        OidcSecurityService.prototype.authorize = function (configId, authOptions) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            this.loginService.login(configId, authOptions);
        };
        /**
         * Opens the Security Token Service in a new window to begin the authentication process.
         *
         * @param authOptions The custom options for the authentication request.
         * @param popupOptions The configuration for the popup window.
         * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken
         *
         * @returns An `Observable<LoginResponse>` containing all information about the login
         */
        OidcSecurityService.prototype.authorizeWithPopUp = function (authOptions, popupOptions, configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.loginService.loginWithPopUp(configId, authOptions, popupOptions);
        };
        /**
         * Manually refreshes the session.
         *
         * @param customParams Custom parameters to pass to the refresh request.
         * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken
         *
         * @returns An `Observable<LoginResponse>` containing all information about the login
         */
        OidcSecurityService.prototype.forceRefreshSession = function (customParams, configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.refreshSessionService.userForceRefreshSession(configId, customParams);
        };
        /**
         * Revokes the refresh token (if present) and the access token on the server and then performs the logoff operation.
         * The refresh token and and the access token are revoked on the server. If the refresh token does not exist
         * only the access token is revoked. Then the logout run.
         *
         * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken
         * @param authOptions The custom options for the request.
         *
         * @returns An observable when the action is finished
         */
        OidcSecurityService.prototype.logoffAndRevokeTokens = function (configId, authOptions) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.logoffRevocationService.logoffAndRevokeTokens(configId, authOptions);
        };
        /**
         * Logs out on the server and the local client. If the server state has changed, confirmed via check session,
         * then only a local logout is performed.
         *
         * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken
         * @param authOptions with custom parameters and/or an custom url handler
         */
        OidcSecurityService.prototype.logoff = function (configId, authOptions) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.logoffRevocationService.logoff(configId, authOptions);
        };
        /**
         * Logs the user out of the application without logging them out of the server.
         * Use this method if you have _one_ config enabled.
         *
         * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken
         */
        OidcSecurityService.prototype.logoffLocal = function (configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.logoffRevocationService.logoffLocal(configId);
        };
        /**
         * Logs the user out of the application for all configs without logging them out of the server.
         * Use this method if you have _multiple_ configs enabled.
         */
        OidcSecurityService.prototype.logoffLocalMultiple = function () {
            return this.logoffRevocationService.logoffLocalMultiple();
        };
        /**
         * Revokes an access token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is
         * provided, then the token from the storage is revoked. You can pass any token to revoke.
         * https://tools.ietf.org/html/rfc7009
         *
         * @param accessToken The access token to revoke.
         * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken
         *
         * @returns An observable when the action is finished
         */
        OidcSecurityService.prototype.revokeAccessToken = function (accessToken, configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.logoffRevocationService.revokeAccessToken(configId, accessToken);
        };
        /**
         * Revokes a refresh token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is
         * provided, then the token from the storage is revoked. You can pass any token to revoke.
         * https://tools.ietf.org/html/rfc7009
         *
         * @param refreshToken The access token to revoke.
         * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken
         *
         * @returns An observable when the action is finished
         */
        OidcSecurityService.prototype.revokeRefreshToken = function (refreshToken, configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.logoffRevocationService.revokeRefreshToken(configId, refreshToken);
        };
        /**
         * Creates the end session URL which can be used to implement an alternate server logout.
         *
         * @param customParams
         * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken
         *
         * @returns A string with the end session url or null
         */
        OidcSecurityService.prototype.getEndSessionUrl = function (customParams, configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.logoffRevocationService.getEndSessionUrl(configId, customParams);
        };
        /**
         * Creates the authorize URL based on your flow
         *
         * @param customParams
         * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken
         *
         * @returns A string with the authorize URL or null
         */
        OidcSecurityService.prototype.getAuthorizeUrl = function (customParams, configId) {
            configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;
            return this.urlService.getAuthorizeUrl(configId, customParams);
        };
        return OidcSecurityService;
    }());
    OidcSecurityService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: OidcSecurityService, deps: [{ token: CheckSessionService }, { token: CheckAuthService }, { token: UserService }, { token: TokenHelperService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: FlowsDataService }, { token: CallbackService }, { token: LogoffRevocationService }, { token: LoginService }, { token: RefreshSessionService }, { token: UrlService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    OidcSecurityService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: OidcSecurityService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: OidcSecurityService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: CheckSessionService }, { type: CheckAuthService }, { type: UserService }, { type: TokenHelperService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: FlowsDataService }, { type: CallbackService }, { type: LogoffRevocationService }, { type: LoginService }, { type: RefreshSessionService }, { type: UrlService }]; } });

    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    function createStaticLoader(passedConfig) {
        return new StsConfigStaticLoader(passedConfig.config);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    function configurationProviderFactory(oidcConfigService, loader) {
        var allLoadPromises = Promise.all(loader.loadConfigs());
        var fn = function () { return allLoadPromises.then(function (configs) { return oidcConfigService.withConfigs(configs); }); };
        return fn;
    }
    var PASSED_CONFIG = new i0.InjectionToken('PASSED_CONFIG');
    var AuthModule = /** @class */ (function () {
        function AuthModule() {
        }
        AuthModule.forRoot = function (passedConfig) {
            return {
                ngModule: AuthModule,
                providers: [
                    // Make the PASSED_CONFIG available through injection
                    { provide: PASSED_CONFIG, useValue: passedConfig },
                    // Create the loader: Either the one getting passed or a static one
                    (passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.loader) || { provide: StsConfigLoader, useFactory: createStaticLoader, deps: [PASSED_CONFIG] },
                    // Load the config when the app starts
                    {
                        provide: i0.APP_INITIALIZER,
                        multi: true,
                        deps: [OidcConfigService, StsConfigLoader, PASSED_CONFIG],
                        useFactory: configurationProviderFactory,
                    },
                    OidcConfigService,
                    PublicEventsService,
                    FlowHelper,
                    ConfigurationProvider,
                    OidcSecurityService,
                    TokenValidationService,
                    PlatformProvider,
                    CheckSessionService,
                    FlowsDataService,
                    FlowsService,
                    SilentRenewService,
                    LogoffRevocationService,
                    UserService,
                    RandomService,
                    HttpBaseService,
                    UrlService,
                    AuthStateService,
                    SigninKeyDataService,
                    StoragePersistenceService,
                    TokenHelperService,
                    LoggerService,
                    IFrameService,
                    EqualityService,
                    LoginService,
                    ParService,
                    AuthWellKnownDataService,
                    AuthWellKnownService,
                    DataService,
                    StateValidationService,
                    ConfigValidationService,
                    CheckAuthService,
                    ResetAuthDataService,
                    ImplicitFlowCallbackService,
                    HistoryJwtKeysCallbackHandlerService,
                    ResponseTypeValidationService,
                    UserCallbackHandlerService,
                    StateValidationCallbackHandlerService,
                    RefreshSessionCallbackHandlerService,
                    RefreshTokenCallbackHandlerService,
                    CodeFlowCallbackHandlerService,
                    ImplicitFlowCallbackHandlerService,
                    ParLoginService,
                    PopUpLoginService,
                    StandardLoginService,
                    AutoLoginService,
                    JsrsAsignReducedService,
                    CurrentUrlService,
                    ClosestMatchingRouteService,
                    DefaultSessionStorageService,
                    BrowserStorageService,
                ],
            };
        };
        return AuthModule;
    }());
    AuthModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AuthModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthModule, imports: [common.CommonModule, i1.HttpClientModule] });
    AuthModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthModule, imports: [[common.CommonModule, i1.HttpClientModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [common.CommonModule, i1.HttpClientModule],
                        declarations: [],
                        exports: [],
                    }]
            }] });

    var AutoLoginAllRoutesGuard = /** @class */ (function () {
        function AutoLoginAllRoutesGuard(autoLoginService, checkAuthService, loginService, configurationProvider) {
            this.autoLoginService = autoLoginService;
            this.checkAuthService = checkAuthService;
            this.loginService = loginService;
            this.configurationProvider = configurationProvider;
        }
        AutoLoginAllRoutesGuard.prototype.canLoad = function (route, segments) {
            var routeToRedirect = segments.join('/');
            return this.checkAuth(routeToRedirect);
        };
        AutoLoginAllRoutesGuard.prototype.canActivate = function (route, state) {
            return this.checkAuth(state.url);
        };
        AutoLoginAllRoutesGuard.prototype.canActivateChild = function (route, state) {
            return this.checkAuth(state.url);
        };
        AutoLoginAllRoutesGuard.prototype.checkAuth = function (url) {
            var _this = this;
            var configId = this.getId();
            return this.checkAuthService.checkAuth().pipe(operators.take(1), operators.map(function (_a) {
                var isAuthenticated = _a.isAuthenticated;
                if (isAuthenticated) {
                    _this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);
                }
                if (!isAuthenticated) {
                    _this.autoLoginService.saveRedirectRoute(configId, url);
                    _this.loginService.login(configId);
                }
                return isAuthenticated;
            }));
        };
        AutoLoginAllRoutesGuard.prototype.getId = function () {
            return this.configurationProvider.getOpenIDConfiguration().configId;
        };
        return AutoLoginAllRoutesGuard;
    }());
    AutoLoginAllRoutesGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AutoLoginAllRoutesGuard, deps: [{ token: AutoLoginService }, { token: CheckAuthService }, { token: LoginService }, { token: ConfigurationProvider }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AutoLoginAllRoutesGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AutoLoginAllRoutesGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AutoLoginAllRoutesGuard, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: AutoLoginService }, { type: CheckAuthService }, { type: LoginService }, { type: ConfigurationProvider }]; } });

    var AutoLoginPartialRoutesGuard = /** @class */ (function () {
        function AutoLoginPartialRoutesGuard(autoLoginService, authStateService, loginService, configurationProvider) {
            this.autoLoginService = autoLoginService;
            this.authStateService = authStateService;
            this.loginService = loginService;
            this.configurationProvider = configurationProvider;
        }
        AutoLoginPartialRoutesGuard.prototype.canLoad = function (route, segments) {
            var routeToRedirect = segments.join('/');
            return this.checkAuth(routeToRedirect);
        };
        AutoLoginPartialRoutesGuard.prototype.canActivate = function (route, state) {
            return this.checkAuth(state.url);
        };
        AutoLoginPartialRoutesGuard.prototype.canActivateChild = function (route, state) {
            return this.checkAuth(state.url);
        };
        AutoLoginPartialRoutesGuard.prototype.checkAuth = function (url) {
            var configId = this.getId();
            var isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);
            if (isAuthenticated) {
                this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);
            }
            if (!isAuthenticated) {
                this.autoLoginService.saveRedirectRoute(configId, url);
                this.loginService.login(configId);
            }
            return isAuthenticated;
        };
        AutoLoginPartialRoutesGuard.prototype.getId = function () {
            return this.configurationProvider.getOpenIDConfiguration().configId;
        };
        return AutoLoginPartialRoutesGuard;
    }());
    AutoLoginPartialRoutesGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AutoLoginPartialRoutesGuard, deps: [{ token: AutoLoginService }, { token: AuthStateService }, { token: LoginService }, { token: ConfigurationProvider }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AutoLoginPartialRoutesGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AutoLoginPartialRoutesGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AutoLoginPartialRoutesGuard, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: AutoLoginService }, { type: AuthStateService }, { type: LoginService }, { type: ConfigurationProvider }]; } });

    var AuthInterceptor = /** @class */ (function () {
        function AuthInterceptor(authStateService, configurationProvider, loggerService, closestMatchingRouteService) {
            this.authStateService = authStateService;
            this.configurationProvider = configurationProvider;
            this.loggerService = loggerService;
            this.closestMatchingRouteService = closestMatchingRouteService;
        }
        AuthInterceptor.prototype.intercept = function (req, next) {
            if (!this.configurationProvider.hasAsLeastOneConfig()) {
                return next.handle(req);
            }
            var allConfigurations = this.configurationProvider.getAllConfigurations();
            var allRoutesConfigured = allConfigurations.map(function (x) { return x.secureRoutes || []; });
            var allRoutesConfiguredFlat = [].concat.apply([], allRoutesConfigured);
            if (allRoutesConfiguredFlat.length === 0) {
                var configId = allConfigurations[0].configId;
                this.loggerService.logDebug(configId, "No routes to check configured");
                return next.handle(req);
            }
            var _a = this.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url), matchingConfigId = _a.matchingConfigId, matchingRoute = _a.matchingRoute;
            if (!matchingConfigId) {
                var configId = allConfigurations[0].configId;
                this.loggerService.logDebug(configId, "Did not find any configured route for route " + req.url);
                return next.handle(req);
            }
            this.loggerService.logDebug(matchingConfigId, "'" + req.url + "' matches configured route '" + matchingRoute + "'");
            var token = this.authStateService.getAccessToken(matchingConfigId);
            if (!token) {
                this.loggerService.logDebug(matchingConfigId, "Wanted to add token to " + req.url + " but found no token: '" + token + "'");
                return next.handle(req);
            }
            this.loggerService.logDebug(matchingConfigId, "'" + req.url + "' matches configured route '" + matchingRoute + "', adding token");
            req = req.clone({
                headers: req.headers.set('Authorization', 'Bearer ' + token),
            });
            return next.handle(req);
        };
        return AuthInterceptor;
    }());
    AuthInterceptor.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthInterceptor, deps: [{ token: AuthStateService }, { token: ConfigurationProvider }, { token: LoggerService }, { token: ClosestMatchingRouteService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AuthInterceptor.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthInterceptor });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AuthInterceptor, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: AuthStateService }, { type: ConfigurationProvider }, { type: LoggerService }, { type: ClosestMatchingRouteService }]; } });

    /**
     * Implement this class-interface to create a custom storage.
     */
    var AbstractSecurityStorage = /** @class */ (function () {
        function AbstractSecurityStorage() {
        }
        return AbstractSecurityStorage;
    }());
    AbstractSecurityStorage.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AbstractSecurityStorage, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AbstractSecurityStorage.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AbstractSecurityStorage });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AbstractSecurityStorage, decorators: [{
                type: i0.Injectable
            }] });

    // Public classes.

    /*
     * Public API Surface of angular-auth-oidc-client
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AbstractSecurityStorage = AbstractSecurityStorage;
    exports.AuthInterceptor = AuthInterceptor;
    exports.AuthModule = AuthModule;
    exports.AutoLoginAllRoutesGuard = AutoLoginAllRoutesGuard;
    exports.AutoLoginPartialRoutesGuard = AutoLoginPartialRoutesGuard;
    exports.LoggerService = LoggerService;
    exports.OidcConfigService = OidcConfigService;
    exports.OidcSecurityService = OidcSecurityService;
    exports.OpenIdConfigLoader = OpenIdConfigLoader;
    exports.PASSED_CONFIG = PASSED_CONFIG;
    exports.PopUpService = PopUpService;
    exports.PublicEventsService = PublicEventsService;
    exports.StateValidationResult = StateValidationResult;
    exports.StsConfigHttpLoader = StsConfigHttpLoader;
    exports.StsConfigLoader = StsConfigLoader;
    exports.StsConfigStaticLoader = StsConfigStaticLoader;
    exports.TokenHelperService = TokenHelperService;
    exports.TokenValidationService = TokenValidationService;
    exports.configurationProviderFactory = configurationProviderFactory;
    exports.createStaticLoader = createStaticLoader;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-auth-oidc-client.umd.js.map
